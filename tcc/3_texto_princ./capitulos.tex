\setlength\abovedisplayskip{0pt} \setlength\belowdisplayskip{0pt}
\setlength\abovedisplayshortskip{0pt} \setlength\belowdisplayshortskip{0pt}

\chapter{Fundamenta\c{c}\~ao Te\'orica}
\label{theorycap}

Neste capítulo serão discutidos e explicados todos os conceitos e 
fundamentos necessários para a compreensão da proposta 
feita nesse trabalho, assim como a abordagem que será utilizada 
para a implementação de todos os componentes que juntos vão compor 
o motor de jogos que será o objeto de estudo.

\section{Modelagem Orientada a Dados}
\label{secdataorienteddesign}

A modelagem orientada a dados (do inglês: \textit{Data Oriented Design}) é 
uma forma de codificar os programas que propõe uma mudança no foco da 
implementação: ao invés de se focar no código, o foco deve estar nos 
dados. Apesar do termo "orientação a dados"\ ter sido usado apenas recentemente, 
a utilização dos conceitos dessa técnica já têm sido usados há muito mais tempo 
do que a introdução do termo.

Orientação a dados foi introduzido por John A. Sharp~\cite{Sharp1980}, cujo objetivo 
era aumentar a eficiência do processador e da utilização da memória. Além disso, o autor 
cita que um dos objetivos dessa técnica de programação é facilitar a concorrência na 
execução dos programas. No seu trabalho é proposta uma metodologia de projeto que 
menciona outro conceito importante, o do fluxo de dados.

Ao se projetar um programa ou sistema, a primeira tarefa a ser feita é determinar o 
fluxo de dados necessários. Essa etapa consiste em determinar quais componentes do 
sistema requerem cada um dos diferentes tipos de dados presente neste, e também 
especificar quais são os componentes que geram novos dados. Depois que o fluxo de dados 
no sistema está completamente especificado, o próximo passo é descrever como os dados 
recebidos por cada componente são transformados nos dados que este componente precisa 
gerar. Sharp defende que qualquer programa pode ser descrito dessa maneira, a 
transformação de um dado conjunto de \textit{inputs} para um certo conjunto de 
\textit{outputs} requeridos.

Um exemplo é o trabalho de Chellappa et al.~\cite{chellappa2008write}, no 
qual é reconhecido o problema da velocidade de acesso à memória principal pelo 
processador, e para solucionar esse problema é dito que os dados de uma aplicação devem 
ser lidos na ordem apropriada. Otimizações feitas pelos compiladores são 
limitadas para o caso da leitura da memória, para realizar esse tipo de 
otimização seria necessário conhecimento do domínio do problema e dos algoritmos 
utilizados, algo que os compiladores não possuem. 

Além disso é reconhecido pelos autores o fato de um \textit{cache miss} causar a perda de 
ciclos e, consequentemente, a perda de operações de ponto flutuante. Para demonstração do 
problema e sua solução através da reestruturação de código, são mostrados no artigo 
dois algoritmos diferentes. Um deles é de particular interesse para esse trabalho, que 
é a multiplicação entre matrizes pois conforme visto na seção~\ref{secmathconcepts}, 
operações de álgebra linear são extensivamente utilizadas em aplicações gráficas.

Como as otimizações feitas pelo compilador são limitadas, é necessário estruturar o 
código de maneira inteligente para que o acesso à memória seja o menos frequente  
possível e para aprimorar a coerência de cache, e é para esse aspecto que a MOD serve.
Um dos objetivos dessa técnica é permitir a leitura sequencial dos dados. Para atingir 
isso, os objetos pertencentes ao domínio do problema são representados por 
identificadores únicos que são utilizados para acessar suas propriedades. Essas 
propriedades são \textit{arrays} de dados que são armazenados na memória de maneira 
contígua, e para utilizar essa técnica de maneira eficiente, é essencial administrar 
esses \textit{arrays} das propriedades para garantir que permaneçam contíguos conforme 
novos dados são adicionados e removidos~\cite{Fontana2017}.

Ao se modelar o código através de uma abordagem orientada a objetos, esta modelagem 
é centrada em volta do problema e da sua solução. Os objetos, que não são coisas reais, 
mas sim o resultado das soluções para o problema apresentado, manipulam apenas os dados 
necessários para representá-los sem nenhuma consideração pelo hardware, pelos 
padrões de dados reais ou de quantidades, por isso essa abordagem permite uma rápida 
prototipagem dos programas pois essas soluções podem ser escritas diretamente da 
modelagem para o código~\cite{fabiandod}.

A MOD utiliza uma abordagem diferente, prevendo onde os dados são mais vistos ou 
esperados através da determinação do fluxo de dados, utiliza o caso 
mais provável para direcionar a escolha do algoritmo. Com isso, ao se utilizar essa 
abordagem pode-se separar os dados mais utilizados dos menos utilizados de tal forma 
que estes não sejam desnecessariamente carregados da memória. Não 
saber como esses dados estão armazenados na memória pode ser 
prejudicial para o desempenho do programa.

\begin{figure}[h]
    \centering
    \captionof{figure}{Orientação a objetos vs. Orientação a Dados. Duas maneiras 
    diferentes de se ler os dados da memória.}
    \begin{subfigure}[b]{0.35\textwidth}
        \includegraphics[width=\textwidth]{../figuras/objectreadingorder}
        \caption{Orientação a Objetos}
        \label{fig:ood}
    \end{subfigure}
    \begin{subfigure}[b]{0.35\textwidth}
        \includegraphics[width=\textwidth]{../figuras/dodreadingorder}
        \caption{Orientação a Dados}
        \label{fig:dod}
    \end{subfigure}
    \par\medskip
    Disponível em: <http://gamesfromwithin.com/data-oriented-design>. Acesso em: 27/05/2017.
    \label{oodvsdod}
\end{figure}

\medskip

A figura~\ref{oodvsdod} apresenta duas maneiras diferentes de se ler dados da memória, 
a primeira ocorre com a programação orientada a objetos, na qual os dados não são lidos 
de maneira contígua, a sequência de chamadas da figura ocorre para todos os objetos 
caso uma função ou uma rotina chame todos os objetos daquele tipo, o que não é uma 
situação incomum de se acontecer. É preciso passar por todas as referências caso seja 
necessário acessar os dados nos níveis mais baixos da árvore, e se uma função usar
somente alguns desses elementos, essa leitura de dados não é muito eficiente. 

Na figura~\ref{fig:dod} há uma separação do objeto em componentes diferentes, e 
componentes do mesmo tipo são agrupados juntos na memória, independentemente do objeto 
de qual vieram. Essa organização resulta em blocos largos de dados homogêneos, 
permitindo o uso eficiente de memória através processamento de dados contíguos. 

Outra proposta da MOD, além da divisão dos objetos em diferentes 
componentes, é utilizar a ordenação de dados ao invés de armazenar 
o estado de um objeto. O motivo de evitar o armazenamento do estado 
de um objeto se deve pela necessidade de condicionais para checar 
esse estado.

O uso de condicionais dentro de um \textit{loop} pode causar 
\textit{branching}, que é o ato da troca da atual sequência de 
instruções do programa por uma outra sequência, caracterizando um 
desvio do comportamento padrão de execução das instruções em 
ordem~\cite{knuthart}. Tal desvio é causado pela execução de uma instrução que 
causa ramificação na execução do programa, instruções com condicionais 
são exemplos de instruções que causam \textit{branching}.

O \textit{branching} é um dos fatores que dificultam o uso de uma técnica conhecida 
por cache \textit{prefetching}, utilizada pelos processadores para aprimorar o 
desempenho, algumas instruções ou dados são buscados da memória principal e movidos 
para o cache antes que seja necessário usá-los~\cite{smith1982}. Para que o 
\textit{prefetching} ocorra, é necessário que o algoritmo responsável pela 
técnica preveja qual ramo será o executado. Caso a escolha esteja errada, 
o erro de previsão causa penalidades no desempenho, e o processador precisa 
despejar as instruções ou dados que haviam sido buscadas de 
antemão~\cite{tianprefetch}.

Se uma referência a um \textit{array} é precedida por uma instrução com 
condicionais, há dois problemas para se realizar o \textit{prefetching} dos 
dados do \textit{array}: o primeiro problema é que o teste condicional da 
instrução pode ser verdadeiro somente para um subconjunto do \textit{array} 
e realizar um \textit{prefetching} no \textit{array} poderia resultar na 
transferência desnecessárias de dados para o cache. O segundo problema é 
que o teste condicional pode estar impedindo o referenciamento de dados 
não existentes no \textit{array}, e realizar o \textit{prefetching} para 
esses dados poderia resultar em comportamento 
inesperado~\cite{vanderwieldataprefetch}.

Para evitar o uso de instruções com condicionais, principalmente em 
métodos que são utilizados com frequência, pode-se separar os dados entre 
aqueles que passam no teste condicional e aqueles que não passam, desta 
forma a verificação com condicionais se torna desnecessária, e o fluxo de 
execução das instruções não é interrompido por \textit{branching}.

O desvio excessivo da ordem de execução padrão de um programa 
também pode ser evitado tratando sempre o caso mais comum primeiro.
 Isso significa que, ao descrever uma transformação sobre um 
\textit{input} de dados, essa transformação deve levar em 
consideração qual será o caso mais comum para esse \textit{input}, 
em termos de estado e de quantidade. 

Em aplicações desenvolvidas com programação orientada a objetos, 
as transformações de dados geralmente são feitas através dos 
métodos implementados de cada classe. Esses métodos estão no 
escopo do objeto e por isso não possuem acesso aos atributos dos 
outros objetos da mesma classe. Consequentemente as instruções 
descritas nos métodos operam somente sobre os atributos do objeto 
que fez a chamada do método.

Essa abordagem é irrealista no contexto de jogos e aplicações 
gráficas, pois em poucas situações o caso mais comum será um 
único objeto. Se o caso mais
comum de \textit{input} para uma transformação é um conjunto 
de objetos, então essa transformação 
deve conter instruções que operam sobre o conjunto inteiro de 
objetos e somente sobre as propriedades que são realmente 
necessárias, otimizando o fluxo de instruções e o acesso à 
memória~\cite{fabiandod}. Transformações sobre um único objeto 
causam poluição desnecessária do cache quando estas precisam 
ser feitas sobre vários objetos em sequência, principalmente 
quando somente uma parcela dos atributos do objeto é 
necessária.

\section{Motor de Jogos}
\label{secgameengine}

O termo e o conceito de motor de jogos surgiram no início da década de 1990, quando a 
empresa \textit{Id Software} lançou o jogo \textit{DOOM} e, juntamente com ele, seu 
motor de jogos conhecido como \textit{DOOM Engine}, que depois foi nomeado como 
\textit{Id Tech 1}~\cite{gregory2009game}.
O jogo \textit{DOOM}, através da \textit{Id Tech 1}, é considerado o primeiro jogo da 
indústria de jogos digitais que possui uma clara separação entre os componentes núcleo 
do jogo, chamada de parte lógica, dos componentes criativos, tais como animações, 
modelos geométricos, sons, imagens, planos de fundo, música, etc.
A \textit{Id Software}, além de ter criado um novo conceito de \textit{software} 
na indústria de jogos que atualmente é considerado padrão em grandes empresas e ter 
gerado uma vasta família de motores de jogos que partiram da \textit{Id Tech 1}, também 
conceberam um novo paradigma para se desenvolver jogos digitais.

A maior vantagem da utilização de motores de jogos consiste na reutilização de código. 
Isso significa que, para rotinas parecidas, ou até mesmo para outros projetos, um mesmo 
código pode ser utilizado mudando-se apenas alguns parâmetros. Além disso, um motor de 
jogos mais completo geralmente permite uma rápida prototipagem de novos projetos,
requer uma habilidade menor por parte dos programadores e minimiza seus esforços 
através de abstrações.

A implementação de um motor de jogos é feita através do desenvolvimento separado de 
diversos componentes. Cada componente é responsável por uma parte específica da parte 
lógica do jogo, o oposto do que era feito na programação tradicional de jogos, cujo 
objetivo primário era maximizar o desempenho para o hardware utilizado. Essa preocupação 
com o desempenho, juntamente com o curto intervalo de tempo que os desenvolvedores tinham 
para terminar os projetos geralmente resultava em códigos que não ficavam conforme os 
preceitos de boa engenharia de software segundo Kruchten et al.~\cite{Kruchten2006}.

Dada a complexidade que é desenvolver um motor de jogos, considerando todos os aspectos que 
este deve abranger, desenvolver um código monolítico sem estrutura arquitetural e sem se 
preocupar com o design geral do sistema, implica em um \textit{software} cujos componentes 
são todos dependentes entre si. O resultado dessa dependência é um sistema frágil, no qual 
pequenas mudanças em alguma parte do código pode afetar outras partes de maneiras não 
óbvias, além de desencorajar os programadores a alterar o código ou refatorá-lo para 
aumentar sua qualidade~\cite{Keenan2011}.

Por esse motivo, é importante que um motor de jogos esteja devidamente modularizado para 
evitar um sistema frágil, e facilitar a adição de novos componentes. É importante lembrar 
que, apesar de ser desejável que os componentes estejam o mais independentes o possível 
entre si, estes devem estar funcionando perfeitamente em sinergia, isto é, um motor de 
jogos não funciona com vários componentes executando separadamente, mas sim com a 
comunicação entre eles de maneira clara e eficiente.

A comunicação e integração entre os diferentes componentes de um motor de jogos faz parte 
da modelagem da arquitetura deste. Conforme apontado por Anderson et 
al.~\cite{Anderson2008}, um problema que ainda persiste atualmente é a falta de material 
na literatura a respeito da modelagem da arquitetura de motores de jogos, sendo que a 
maior parte da pesquisa disponível foca somente nos componentes separados, como 
renderização, inteligência artificial (IA) ou rede. Ainda é salientado pelo autor que 
não há um consenso sobre os limites que separam um jogo do seu motor, portanto 
há espaço a ser explorado nessa área.

A quantidade de componentes presentes em um motor de jogos é altamente dependente da 
complexidade desejada para o jogo sendo desenvolvido, alguns dos componentes mais 
presentes são: componente gráfico, colisões, física, inteligência artificial, rede, som 
e animação.

\section{Conceitos Matemáticos}
\label{secmathconcepts}

Qualquer motor de jogos necessita de uma biblioteca matemática, uma vez que 
jogos são aplicações as quais são extremamente dependentes de operações e 
conceitos matemáticos. 
Essas bibliotecas fornecem diversas utilidades, algoritmos e funções 
matemáticas, tais como: estruturas de dados personalizadas de vetores, 
matrizes e quaternions; operações matriciais e vetoriais; rotações e 
interpolações de quaternions; trigonometria; operações geométricas com 
linhas, raios, esferas, etc., manipulação de \textit{splines}, integração 
numérica, e quaisquer outras utilidades que os desenvolvedores 
necessitarem~\cite{gregory2009game}.

A área da computação gráfica está intimamente ligada às áreas da matemática de 
álgebra linear e geometria analítica, a maior parte dos conceitos matemáticos empregados 
neste trabalho pertencem a uma destas áreas. Visto que ambas estas áreas são vastas e vão 
muito além do escopo deste trabalho, o restante desta seção tratará dos conceitos e 
propriedades que são relevantes para a computação gráfica apenas.

Verth e Bishop~\cite{Verth:2008} e Mortenson~\cite{mortenson1999mathematics} fizeram uma 
cobertura de toda a matemática essencial utilizada em motores de jogos. O restante 
da seção cobrirá apenas os tópicos essenciais e para uma abordagem mais completa do 
assunto, esses trabalhos deverão ser consultados. Todos os conceitos apresentados aqui 
são utilizados para a elaboração da biblioteca matemática presente neste trabalho.

\subsection{Vetores e Pontos}

Vetores e pontos são as estruturas essenciais de todos os objetos presentes em 
aplicações gráficas. 
Os pontos representam posições do espaço e podem ser utilizados para determinar os 
vértices da superfície de um objeto, que consequentemente determinará seu formato 
(chamado de modelo). Os pontos também podem representar a posição de um objeto no 
espaço, a qual geralmente se refere ao centro do objeto. Se os pontos de um objeto 
forem alterados, o modelo desse objeto também será alterado.

Vetores (no campo da geometria) são entidades que possuem uma direção, um comprimento, 
chamado de magnitude, e um sentido (por exemplo, da esquerda para direita ou de baixo 
para cima), os vetores representam a diferença entre dois pontos. São utilizados para 
armazenar grandezas (como velocidade, gravidade, aceleração, atrito, etc.) e direções.
Há alguns casos específicos de vetores que recebem nomeações 
diferentes, por exemplo vetores cuja magnitude é igual a 1 são chamados de vetores 
unitários ou vetores normalizados. Um vetor cuja magnitude é igual a 0 é chamado de 
vetor zero, e não possui nenhuma direção. 

Para representar um vetor no computador, utiliza-se a chamada "base Euclidiana padrão", 
composta pelos três vetores unitários linearmente independentes $i$, $j$ e $k$ que são 
perpendiculares entre si para o caso do espaço tridimensional $\mathbb{R}^3$. Para o 
espaço bidimensional $\mathbb{R}^2$, utiliza-se somente os vetores $i$ e $j$. 

Utilizando essa base, pode-se representar unicamente qualquer vetor no espaço através 
de uma combinação linear dos três vetores base da seguinte maneira: 

\begin{equation}
    \centering
    v = xi + yj + zk
\end{equation}

Os coeficientes $x$, $y$ e $z$ representam o deslocamento em cada um dos eixos. A 
figura~\ref{3dbasisvector} demonstra como um vetor é representado utilizando a base 
Euclidiana padrão. Esses coeficientes são utilizados para representar um vetor 
algebricamente através de uma tripla $(x,y,z)$, ou uma dupla para o caso dos vetores 
2D, e são conhecidos como componentes do vetor.

\begin{figure}[h]
    \centering
    \captionof{figure}{Representação de um Vetor na Base Tridimensional.}
    \includegraphics[width =.6\textwidth]{../figuras/3dbasisvector}
    \par\medskip
    Fonte: \cite{Verth:2008}.
    \label{3dbasisvector}
\end{figure}

Com essa representação algébrica, pode-se definir as operações sobre vetores tão 
utilizadas na computação gráfica.

\subsection{Operações Sobre Vetores}

Nesta seção serão apresentadas operações que podem ser feitas sobre vetores e entre 
vetores. Para todas as operações serão utilizados como exemplo vetores no espaço 3D.
\subsubsection{Adição}

A adição entre dois vetores é feita através da soma de cada um dos componentes de um 
vetor com os componentes correspondentes do outro vetor.

\begin{equation}
    \begin{aligned}
        v1 + v2 = (x_1, y_1, z_1) + (x_2, y_2, z_2) \\
        v1 + v2 = (x_1 + x_2, y_1 + y_2 , z_1 + z_2)
    \end{aligned}
\end{equation}

\subsubsection{Subtração}

A subtração entre dois vetores é semelhante à adição, porém são feitas operações de 
substrações entre os componentes dos operandos.

\begin{equation}
    \begin{aligned}
        v1 - v2 = (x_1, y_1, z_1) - (x_2, y_2, z_2) \\
        v1 - v2 = (x_1 - x_2, y_1 - y_2, z_1 - z_2)
    \end{aligned}
\end{equation}

Observa-se que assim como a subtração entre escalares, a subtração entre vetores também 
não é comutativa.

\subsubsection{Multiplicação por Escalar}

Dado um certo coeficiente $k$, a multiplicação de um vetor $v$ pelo escalar $k$ é dada 
pela multiplicação do escalar por cada um dos componentes do vetor:

\begin{equation}
    \begin{aligned}
        kv = k(x, y, z)\\
        kv = (kx, ky, kz)
    \end{aligned}
\end{equation}

\subsubsection{Igualdade Entre Vetores}

Um vetor $v1$ é igual a um vetor $v2$, se todos os componentes de $v1$ forem iguais aos 
componentes correspondentes de $v2$. 

\begin{equation}
    \begin{aligned}
        v1 = v2\\
        (x_1, y_1, z_1) = (x_2, y_2, z_2)\\
        x_1 = x_2, y_1 = y_2, z_1 = z_2
    \end{aligned}
\end{equation}

\subsubsection{Magnitude}

O operador de magnitude serve para calcular o comprimento de um vetor. Para o fazê-lo, 
a norma utilizada é a norma Euclidiana, cujo cálculo consiste na raiz quadrada da soma  
dos quadrados dos componentes. O operador de norma é denotado por: $||v||$. Dado um 
vetor $v$, o tamanho do vetor $d$ é dado por:

\begin{equation}
    \begin{aligned}
        ||v|| = d = \sqrt{x^2 + y^2 + z^2}
    \end{aligned}
\end{equation}

\subsubsection{Normalização}

A normalização de um vetor cria um vetor unitário $v'$ a partir de um vetor $v$, 
mudando sua magnitude para 1, porém mantendo sua direção. Isso é feito a partir da
divisão de um vetor pela sua norma:

\begin{equation}
    \begin{aligned}
        v' = \frac{v}{||v||}
    \end{aligned}
\end{equation}

\subsubsection{Produto Escalar}

O produto escalar entre dois vetores, como o nome sugere, resulta em um escalar a partir 
dos operandos, a operação é feita multiplicando-se os dois vetores 
componente-a-componente e depois somando os resultados:

\begin{equation}
    \begin{aligned}
        v1 \cdotp v2 = v1_xv2_x + v1_yv2_y + v1_zv2_z
    \end{aligned}
\end{equation}

Se os vetores $v1$ e $v2$ formarem um ângulo de 90 graus entre si, então o produto 
escalar entre eles será zero. Então pode-se dizer que dois vetores serão 
perpendiculares, ou ortogonais, quando $v1 \cdotp v2 = 0$.

Além de verificar a ortogonalidade entre dois vetores, o produto escalar pode fornecer 
outras informações, por exemplo, se $v1 \cdotp v2 > 0$, então o ângulo entre eles é 
menor do que 90 graus, se $v1 \cdotp v2 < 0$, então o ângulo entre eles é maior do que 
90 graus, esse teste não requer que os vetores estejam normalizados.

\subsubsection{Produto Vetorial}

O produto vetorial, opostamente ao produto escalar, tem como resultado da operação um 
vetor. O vetor resultante $w$ do produto vetorial entre $v1$ e $v2$ será sempre 
ortogonal a estes. Como essa operação não é comutativa, a direção do vetor resultante 
dependerá da ordem dos operandos, ou seja, há duas saídas possíveis dessa operação, uma 
é a negação da outra. O produto vetorial é determinado pela fórmula:

\begin{equation}
    \begin{aligned}
        v1 \times v2 = (v1_yv2_z - v2_yv1_z, v1_zv2_x - v2_zv1_x, v1_xv2_y - v2_xv1_y)
    \end{aligned}
\end{equation}

A figura~\ref{piccrossproduct} demonstra geometricamente um produto vetorial. Os usos mais 
comuns para o produto vetorial é para gerar um vetor ortogonal a outros dois e para 
verificar se dois vetores são paralelos entre si.

Diferentemente do produto escalar, o produto vetorial não é definido para vetores 2D.

\begin{figure}[h]
    \centering
    \captionof{figure}{Produto vetorial com os dois possíveis resultados representados.}
    \includegraphics[width =.4\textwidth]{../figuras/crossproduct}
    \par\medskip
    Disponível em: <https://en.wikipedia.org/wiki/Cross\_product>. Acesso em: 27/05/2017.
    \label{piccrossproduct}
\end{figure}

\subsection{Matrizes}
\label{matrices}

Matrizes são \textit{arrays} bidimensionais nas quais cada valor individual é chamado de 
elemento. A descrição de uma matriz é feita especificando o seu número de linhas e número 
de colunas, sendo $m$ o número de linhas e $n$ o número de colunas, é dito que é uma matriz 
$m$ por $n$, denotado por $m\ \times n$. A relação da quantidade de linhas e colunas é 
também conhecida como o tamanho da matriz.

Uma linha é uma sequência de elementos na horizontal da esquerda para a direita, enquanto 
que uma coluna é uma sequência de elementos na vertical de cima para baixo. Para 
referenciar um elemento específico de uma matriz $A$, usa-se a notação: $a_{i,j}$, onde 
$i$ referencia uma linha e $j$ uma coluna. Dessa maneira, o elemento $a_{1,2}$ é o elemento 
que está na primeira linha e na segunda coluna na matriz A.
O conjunto de elementos os quais o número da linha é igual ao número da coluna (ex: 
$a_{1,1}$) é chamado de diagonal principal.

Alguns casos específicos de matrizes recebem denotações especiais. A seguir serão 
listadas algumas dessas matrizes específicas:
\begin{itemize}
    \item Matriz quadrada: matriz cujo número de linhas é igual ao número de colunas 
    \item Matriz zero ou nula: matriz na qual todos os elementos são iguais a zero
    \item Matriz diagonal: matriz cujos únicos elementos que não são zero são os da 
        diagonal principal
    \item Matriz Identidade: matriz na qual todos os elementos da diagonal principal são 
        iguais a um, e o restante igual a zero. A matriz identidade é denotada por $I$.
    \item Matriz coluna: matriz que só possui uma coluna de elementos
    \item Matriz linha: matriz que só possui uma linha de elementos
\end{itemize}

Uma característica importante das matrizes linha e coluna é 
que elas podem ser utilizadas para representar vetores matricialmente. A Representação 
matricial dos vetores é necessária para se realizar multiplicações entre vetor e 
matriz, tal operação será explicada posteriormente.

\subsection{Operações Sobre Matrizes}

Nesta seção serão apresentadas operações feitas sobre matrizes, entre matrizes e também 
entre matrizes e vetores.

\subsubsection{Igualdade entre Matrizes}

Duas matrizes são iguais se elas possuem a mesma dimensão e todos os seus elementos 
correspondentes são iguais. Ou seja, para duas matrizes de dimensão $m \times n$:

\begin{equation}
    \begin{aligned}
        A = B\\
        a_{i,j} = b_{i,j}\\
        \forall i \in {1..m} \land \forall j \in {1..n}
    \end{aligned}
\end{equation}

\subsubsection{Adição e Subtração}

Dadas duas matrizes $A$ e $B$, a soma entre elas é feita de maneira semelhante à soma de 
vetores, soma-se componente-a-componente. Sendo $S$ a soma de $A$ e $B$, teremos:

\begin{equation}
    \begin{aligned}
        S = A + B\\
        s_{i,j} = a_{i,j} + b_{i,j}
    \end{aligned}
\end{equation}

A subtração é feita de maneira semelhante, subtraindo-se os componentes ao invés de 
somá-los. Assim como números reais e vetores, a subtração não é comutativa para matrizes.
Nota-se que para realizar essas operações, os tamanhos de $A$, $B$ e $S$ devem ser 
iguais. 

\subsubsection{Multiplicação por Escalar}

De maneira similar à multiplicação de um vetor por um escalar, dado um escalar $k$, 
cada elemento da matriz é multiplicado por $k$. Sendo $P$, a multiplicação da matrix $A$ 
pelo escalar $k$, esta é dada por:

\begin{equation}
    \begin{aligned}
        P = kA\\
        p_{i,j} = k \dot a_{i,j}
    \end{aligned}
\end{equation}

\subsubsection{Matriz Transposta}

A transposta de uma matriz $A$, denotada por $A^T$, troca as linhas pelas colunas de $A$ 
e vice-versa. Isso é feito trocando os elementos ao longo da diagonal principal, de 
tal forma que: $(A^T)_{i.j} = (A)_{j,i}$

\subsubsection{Blocos de Matrizes}

Uma convenção para a representação de matrizes é representá-las como blocos de 
submatrizes, ao invés de representá-las com todos os elementos, por exemplo: \\

$
    \begin{bmatrix}
        1 & 2 & 0 \\
    -4 & 5 & 0 \\
        0 & 0 & 1 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
        A & 0 \\
        0^T & 1 \\
    \end{bmatrix}
$

\vspace{1cm}

Onde $0^T$ é uma linha de zeros e A:\\ 

$A =  \begin{bmatrix}
        1 & 2 \\
       -4 & 5 \\
      \end{bmatrix}$

\subsubsection{Multiplicação Entre Matrizes}

Essa é a operação de matrizes mais utilizada em aplicações gráficas, também conhecida 
como produto de matrizes. Com essa operação é possível fazer duas coisas extensivamente 
usadas: a primeira é a transformação de um vetor multiplicando-o por uma matriz. A 
segunda é multiplicar duas matrizes juntas para formar uma única matriz que realiza as 
transformações combinadas daquelas.

O produto $C$ das matrizes $A$ e $B$ é denotado da mesma maneira que números reais: 
$C = AB$. Para calcular os elementos do produto $c_{i,j}$, realiza-se um produto 
escalar da linha $i$ de $A$ com a coluna $j$ de B, isso pode ser representado da 
seguinte maneira:

\begin{equation}
    \begin{aligned}
        C_{M,Q} = A_{M,N} \times B_{P,Q} \\
        c_{i,j} = \displaystyle\sum_{k=0}^{n-1} a_{i,k}b_{k,j}
    \end{aligned}
\end{equation}

Onde $N = P$, ou seja, para se realizar o produto escalar entre as linhas e as colunas, 
elas devem possuir a mesma dimensão. O número de colunas de uma matriz deve ser igual ao 
número de linhas da outra. Isso também implica que apenas matrizes quadradas podem ser 
multiplicadas por si mesmas. 

Conforme mencionado na seção~\ref{matrices}, vetores podem ser representados 
matricialmente através de uma matriz linha ou matriz coluna, essas representações são 
utilizadas para realizar transformações sobre vetores, através de uma multiplicação 
entre matriz e vetor, para o caso de um vetor representado por uma matriz coluna, a 
multiplicação de um vetor $v$ por uma matriz $A$ é dada por: 

\begin{equation}
    \begin{bmatrix}
        a_{1,1} & a_{1,2} & a_{1,3}\\
        a_{2,1} & a_{2,2} & a_{2,3}\\
        a_{3,1} & a_{3,2} & a_{3,3}\\
    \end{bmatrix}
    \begin{bmatrix}
        v_x \\
        v_y \\
        v_z \\
    \end{bmatrix}
\end{equation}

Para que a multiplicação possa ser realizada nesse caso, o número de colunas da matriz 
deve corresponder ao número de elementos do vetor, o resultado dessa multiplicação 
será:

$
Av = (v \cdotp a_{1}^{T}, v \cdotp a_{2}^{T}, v \cdotp a_{3}^{T})
$

Onde $a_{1}^{T}$, $a_{2}^{T}$ e $a_{3}^{T}$ são as linhas 1, 2 e 3 da matriz $A$, 
respectivamente. 

Caso uma matriz linha seja utilizada para representar o vetor, o número de linhas da 
matriz deve corresponder ao número de elementos do vetor, e o vetor deverá ser colocado 
à esquerda da operação.
É importante salientar que a multiplicação entre matrizes não é comutativa, apesar de 
ainda ser associativa como vetores e números reais.

A matriz identidade (seção~\ref{matrices}), é o elemento neutro da multiplicação de 
matrizes, isto é, para qualquer matriz $A$, a multiplicação pela matriz identidade $I$ 
resultará em $A$:

\begin{equation}
    \begin{aligned}
        A \cdotp I = I \cdotp A = A
    \end{aligned}
\end{equation}

\subsubsection{Matriz Inversa}

A inversa de uma matriz $A$, definida como $A^{-1}$, é uma matriz a qual multiplicada por 
$A$ resulta na matriz identidade $I$:

\begin{equation}
    \begin{aligned}
        A \cdotp A^{-1} = I
    \end{aligned}
\end{equation}

E: 

\begin{equation}
    \begin{aligned}
        A^{-1} \cdotp A = I
    \end{aligned}
\end{equation}

Para que essa multiplicação possa ocorrer, o número de colunas da matriz inversa 
precisa ser igual ao número de linhas da original, e a recíproca também deve ser 
verdadeira. Por isso, uma matriz e sua inversa devem ser quadradas e de mesma dimensão, 
portanto nem todas as matrizes possuem uma inversa, já nem todas as matrizes são 
quadradas. 

Uma das utilidades da matriz inversa é que ela pode reverter a transformação feita 
pela sua matriz original, multiplicando o vetor transformado pela inversa da matriz 
que realizou a transformação.

Existem várias maneiras de se computar a matriz inversa, o método utilizado neste 
trabalho é o método de Cramer~\cite{cramer1750introduction}.

\subsubsection{Determinante}

O determinante é uma quantidade escalar criada a partir da avaliação dos elementos de 
uma matriz quadrada. Para o caso de uma matriz $2 \times 2$, se utilizarmos as colunas 
dela como os lados de um paralelogramo, então o valor absoluto do determinante é igual 
a área do paralelogramo. Já uma matrix $3 \times 3$, o valor absoluto do determinate 
é igual ao volume de um paralelepípedo. 

O determinante pode ser representado de duas maneiras, por det$(A)$ ou $|A|$. A segunda 
é mais comum ao se mostrar os elementos da matriz. 

O cálculo do determinante é dependente da dimensão da matriz. No escopo de aplicações 
gráficas, apenas o cálculo dos determinantes de matrizes $2 \times 2$ e $3 \times 3$ 
são necessários.

O determinante de uma matriz $2 \times 2$ é dado por:

\begin{equation}
    \begin{aligned}
        \begin{vmatrix}
            a & b \\
            c & d
        \end{vmatrix}
        = 
        ad - bc
    \end{aligned}
\end{equation}

E o determinante de uma matriz $3 \times 3$ é dado por:

\begin{equation}
    \begin{aligned}
        \begin{vmatrix}
            a & b & c\\
            d & e & f\\
            g & h & i\\
        \end{vmatrix}
        = 
        a(ei - fh) -b(di - fg) + c(dh - eg)
    \end{aligned}
\end{equation}

\subsection{Transformações Afins}

As transformações afins mapeiam pontos e vetores de um espaço afim para outro, e elas 
podem ser aplicadas utilizando-se operações matriciais.

De uma maneira simples, uma transformação afim pode ser representada por uma 
multiplicação de matriz seguida por uma adição de vetor:

\begin{equation}
    \begin{aligned}
        Ax + y
    \end{aligned}
\end{equation}

Onde $A$ é uma matrix $m \times n$, $y$ é um vetor de tamanho $m$, e $x$ consiste nas 
coordenadas $(x_0,\ldots,x_{n-1})$. Essa transformação pode ser representada utilizando 
blocos de matrizes: 

\begin{equation}
    \begin{bmatrix}
        A & y\\
        0^T & 1\\
    \end{bmatrix}
    \begin{bmatrix}
        x \\
        1 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
        Ax + y\\
        1\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Para que essa multiplicação possa ocorrer, é preciso representar $x$ com um componente 
adicional cujo valor é $1$. Computacionalmente essa abordagem não é atrativa, pois 
armazenar um vetor de zeros $0^T$, o $1$ no canto inferior direito e a dimensão extra 
de $x$ consomem memória desnecessariamente. Por isso, geralmente utiliza-se uma 
representação para transformações afins na qual esses termos são implícitos, como 
por exemplo uma matriz de $m \times (n + 1)$ dimensões. Portanto, ao se trabalhar com 
transformações no espaço $\mathbb{R}^3$, uma transformação afim será representada por 
uma matriz $4 \times 4$. De maneira análoga, uma transformação afim no espaço 
$\mathbb{R}^2$ será representada por uma matriz $3 \times 3$.

Em aplicações gráficas, essas transformações são utilizadas para a manipulação dos 
objetos em um espaço virtual, também chamado de cena. As transformações afins mais 
utilizadas são para alterar a posição, a orientação e o tamanho de um objeto, essas 
transformações são a translação, a rotação e a escala, respectivamente.

\subsubsection{Translação}

A translação move um ponto, ou um conjunto de pontos para o caso de um objeto, 
através do espaço. Já que todos os pontos de um objeto são transladados, a sua forma e 
tamanho não são alterados.

Para o caso de uma translação de um ponto no $\mathbb{R}^3$ com um deslocamento 
representado por um ponto $t$, a matriz de translação será definida por uma matriz 
$4 \times 4$ da seguinte forma:

\begin{equation}
    \begin{bmatrix}
        1 & 0 & 0 & t_x\\
        0 & 1 & 0 & t_y\\
        0 & 0 & 1 & t_z\\
        0 & 0 & 0 & 1\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Onde $t_x$, $t_y$ e $t_z$ representam os deslocamentos nos eixos $x$, $y$ e $z$ 
respectivamente.

\subsubsection{Rotação}

A rotação altera a orientação de um vetor em torno de algum eixo. Para um 
certo ponto, sua rotação é feita movendo-o ao longo de um arco planar uma distância 
constante de um outro ponto, chamado de centro da rotação. Existem dois tipo de 
rotações, as rotações puras que são feitas em torno dos três eixos que constituem a 
base Euclidiana padrão ($i$, $j$ e $k$), e as rotações que são feitas em torno de um 
eixo arbitrário qualquer. 

As rotações puras, apesar de serem mais simples, não são muito úteis, pois são 
limitadas, principalmente se for requerido realizar uma rotação em torno de um eixo que 
é a combinação de outros, ou passar o eixo de rotação como argumento. Por esses motivos, 
as rotações puras não serão utilizadas nesse trabalho, ao invés disso, uma técnica de 
rotação mais eficiente será utilizada, que é a fórmula de rotação de Rodrigues, que 
permite rotacionar um vetor em torno de qualquer eixo arbitrário.

A fórmula de rotação de Rodrigues é definida por: 

\begin{equation}
    \begin{aligned}
        R = I + (\sin \theta)K + (1 - \cos \theta)K^2
    \end{aligned}
\end{equation}

\vspace{.5cm}

Onde $I$ é a matriz identidade, $\theta$ é o quanto se quer rotacionar e $K$ é uma 
matriz dada por:

\begin{equation}
    \begin{bmatrix}
        0 & -k_z & k_y\\
        k_z & 0 & -k_x\\
        -k_y & k_x & 0\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Na qual $k_x$, $k_y$ e $k_z$ são os componentes do eixo em torno do qual se deseja 
rotacionar.

\subsubsection{Escala}

A escala modifica o tamanho de um vetor multiplicando cada um de seus componentes por 
um fator escolhido. As diferenças da transformação de escala da multiplicação por 
escalar dos vetores é que na escala, o coeficiente é sempre positivo e pode usar um 
fator de escala diferente para cada um dos componentes do vetor. Se todos os fatores 
forem iguais, a transformação é chamada de escala uniforme, caso contrário, é chamada 
de escala não uniforme. Uma escala não uniforme pode ser utilizada para deixar um 
objeto com o dobro da altura porém com metade da largura, por isso a escala é 
considerada uma transformação de deformação. 

Como um ponto por si só não possui um comprimento, o que a escala efetivamente faz é 
alterar a distância relativa desse ponto de um outro ponto $C_s$, conhecido como o 
centro da escala, geralmente coincidindo com o centro de um objeto. Para um conjunto 
de pontos, a escala irá alterar a distância relativa entre eles, porém irá manter a 
mesma forma relativa. 

A transformação de escala é representada por uma matriz da seguinte maneira:

\begin{equation}
    \begin{bmatrix}
        a & 0 & 0 & 0\\
        0 & b & 0 & 0\\
        0 & 0 & c & 0\\
        0 & 0 & 0 & 1\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Onde $a$, $b$ e $c$ são os fatores de escala nas direções $x$, $y$ e $z$, 
respectivamente.

\subsection{Quaternions}

Quaternions, aparte de sua definição matemática, são estruturas que possuem quatro 
elementos, e são utilizados em aplicações gráficas pois são capazes de realizar 
rotações em objetos sem o problema do \textit{Gimbal Lock}, no qual uma certa sequência 
de rotações faz com que dois eixos se alinhem, resultando na perda de um grau de 
liberdade~\cite{hughes2014computer}.

Os quaternions são definidos pelos seguintes quatro elementos: 

\begin{equation}
    q = w + xi + yj + zk
\end{equation}

\vspace{.5cm}

Os componentes $i$, $j$ e $k$ podem ser considerados a base padrão para todos os 
quaternions, então essa representação pode ser simplificada como: 

\begin{equation}
    \begin{aligned}
        q = (w, x, y, z)\\
        ou\\
        q = (w,v)
    \end{aligned}
\end{equation}

\vspace{.5cm}

Onde $w$ é a parte escalar, e $v$ a parte vetorial. 

Além de evitar o \textit{Gimbal Lock}, os quaternions podem realizar rotações em torno 
de eixos arbitrários pois podem ser construídos a partir de um ângulo e um eixo. A 
partir de um ângulo $\theta$ e um eixo $k$, um quaternion é construído da seguinte 
forma:

\begin{equation}
    \begin{aligned}
        w = \cos (\theta / 2)\\
        x = k_x \cdotp \sin (\theta / 2)\\
        y = k_y \cdotp \sin (\theta / 2)\\
        z = k_z \cdotp \sin (\theta / 2)\\
    \end{aligned}
\end{equation}

\vspace{.5cm}

De maneira análoga aos vetores, quaternions também podem ser somados entre si e 
multiplicados por um escalar. 

Sua fórmula de norma também é semelhante:

\begin{equation}
    \begin{aligned}
        ||q|| = \sqrt{(w^2 + x^2 + y^2 + z^2)}
    \end{aligned}
\end{equation}

\vspace{.5cm}

Um quaternion normalizado $q'$ é igual a:

\begin{equation}
    \begin{aligned}
        q' = \frac{q}{||q||}
    \end{aligned}
\end{equation}

\vspace{.5cm}

O seu produto escalar também é semelhante ao dos vetores: 

\begin{equation}
    \begin{aligned}
        q_1 \cdotp q_2 = w_1w_2 + x_1x_2 + y_1y_2 + z_1z_2
    \end{aligned}
\end{equation}

Uma característica importante dos quaternions é que estes podem ser convertidos para 
uma matriz, sendo possível combiná-los com outras transformações, a versão matricial 
toma a seguinte forma: 

\begin{equation}
    M_q = 
    \begin{bmatrix}
        1 - 2y^2 - 2z^2 & 2xy - 2wz & 2xz + 2wy\\
        2xy + 2wz & 1 - 2x^2 - 2z^2 & 2yz - 2wx\\
        2xz - 2wy & 2yz + 2wx & 1 - 2x^2 - 2y^2\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Para transformá-lo em matriz, o quaternion deve estar normalizado.

Assim como matrizes, quaternions também podem ser concatenados através de 
multiplicações, permitindo dessa maneira combinações de transformações sucessivas. 
A multiplicação entre dois quaternions é dada por:
\begin{equation}
    \begin{aligned}
        q_2 \times q_1 = (w_1w_2 - v_1 \cdotp v_2, w_1v_2 + w_2v_1 + v_2 \times v_1)
    \end{aligned}
\end{equation}

\section{O \textit{Pipeline} de Visualização}
\label{viewingpipelinesec}

Todos os vértices presentes em uma cena, desde os seus valores originais conforme 
descritos em um sistema de modelagem de objetos até passarem pelo 
processo de rasterização e aparecerem na tela, passam por uma série de etapas nas quais 
ocorrem mudanças de sistemas de coordenadas. Essas etapas combinadas sequencialmente 
formam o que é chamado de pipeline de visualização, ou também pipeline de transformação 
ou pipeline de geometria~\cite{hughes2014computer}.

Os vértices passam de uma etapa a outra através de transformações. Essas transformações 
são feitas através de aritmética de matrizes. 

\begin{figure}[h!]
    \centering
    \captionof{figure}{Representação do pipeline de visualização com as transformações 
    que são realizadas em cada etapa e também o nome das operações que passam os vértices 
    de uma etapa a outra.}
    \includegraphics[width =.8\textwidth]{../figuras/viewingpipeline}
    \par\medskip
    Fonte:~\cite{hughes2014computer}.
    \label{viewingpipelinerep}
\end{figure}

\subsection{Coordenadas do Objeto}

O sistema de coordenadas do objeto é considerado o sistema de coordenadas inicial, não 
processado de um objeto. Neste sistema as coordenadas são locais e o ponto de referência 
é o centro do objeto. Quando se define uma malha de polígonos, os vértices estão nesse 
sistema de coordenadas.

\subsection{Coordenadas do Mundo}
\label{worldcoord}

Nesse estágio os vértices são convertidos para um sistema de coordenadas unificado do 
mundo (cena). Essa conversão é feita multiplicando os vértices por uma matriz conhecida 
como matriz de transformação. Essa matriz é uma combinação de transformações de 
translação, rotação e escala, podendo ter os três tipos, nenhum deles ou qualquer 
combinação intermediária (por exemplo apenas translação e escala). 

Isso significa que, para uma determinada cena, todos os objetos que possuem uma forma 
associada a estes também possuem uma matriz de transformação associada, essa matriz é 
o recurso utilizado para posicioná-los do mundo da aplicação.

\subsection{Coordenadas de Visualização}

Nesse estágio as coordenadas são convertidas para o \textit{eye space}, no qual os 
vértices são posicionados conforme o ponto de vista de uma câmera virtual, que é um 
objeto abstrato de uma cena o qual possui uma posição e uma orientação. Nesse estágio os
objetos da cena são posicionados de acordo com esses dois parâmetros da câmera.

A conversão é feita através da matriz de visualização, que é construída a partir da 
posição da câmera, da sua orientação e também de um vetor que diz qual dos eixos é 
considerado o eixo com a direção "para cima"\ da câmera. Tradicionalmente se utiliza o 
eixo $y$ (i e. $(0,1,0)$), porém outros eixos podem ser utilizados.

\subsection{Coordenadas Truncadas}

Nesse estágio ocorre uma normalização do formato do volume de visualização da câmera. 
Renderizar a cena toda é um processo custoso e redundante pois a câmera muitas vezes 
não é capaz de visualizar a cena toda. Por este motivo, são somente renderizados na cena 
os objetos que estão totalmente ou parcialmente no campo de visão de câmera. Esse campo 
de visão é definido por um sólido com um certo volume e a modelagem desse sólido é 
dependente da técnica de projeção empregada. 

A projeção é um processo que converte as coordenadas de um espaço tridimensional para um 
espaço truncado. Objetos que estão parcialmente visíveis têm seus vértices que estão fora 
do volume de visualização realocados para as extremidades do mesmo. 
A conversão é feita através da matriz de projeção, e sua construção também é dependente 
da técnica de projeção.

A técnica de projeção utilizada neste trabalho é a projeção de perspectiva, esta técnica 
transforma o volume de visualização em uma pirâmide truncada, conhecida como 
\textit{frustum} de visualização. O topo da pirâmide é chamado de plano perto, e é o 
início da visualização da câmera. A base da pirâmide é chamada de plano longe, e é o 
fim da visualização da câmera. Quanto mais próximo os objetos estão da base da 
pirâmide, menor eles irão aparentar na cena.

\subsection{Coordenadas Normalizadas do Dispositivo}

Nesse estágio é feita uma normalização das coordenadas 3D para um intervalo entre 
$[-1,1]$ para cada um dos eixos. Nessa normalização, $-1$ e $1$ representam os extremos 
do dispositivo tanto na vertical quanto na horizontal.
Esse estágio não é dependente de nenhum argumento da aplicação e é gerenciado 
pelo componente do hardware responsável.

\subsection{Coordenadas da Tela}

As coordenadas chegam nesse estágio somente na fase final de renderização, que é o 
processo de rasterização (seção~\ref{renderingpipelinesec}), as coordenadas 3D 
normalizadas são convertidas para coordenadas de janela 2D e assim como o estágio 
anterior, este estágio é gerenciado pelo hardware. Após esse estágio, os 
pixels terão suas coordenadas definidas para serem devidamente dispostos na tela da 
aplicação.

\section{Malhas de Polígono}

Malhas de polígono são uma forma de representar objetos em aplicações gráficas, elas são 
populares pois requerem um baixo custo computacional. Uma malha consiste em vários 
polígonos agrupados ao longo de suas arestas para formar a superfície do objeto. 

O polígono mais utilizado é o triângulo, por alguns motivos que facilitam o seu uso. 
Por exemplo, três vértices é o mínimo necessário para se formar um plano, então os 
vértices de um triângulo estarão garantidamente no mesmo plano, o que não é verdade 
para outros polígonos com maiores dimensões, e quando todos os pontos de um polígono 
não são coplanares, não se sabe como o interior deve ser preenchido nesse caso. 
Triângulos também são polígonos atômicos (dividir um triângulo em dois sempre resultará 
em dois polígonos) e qualquer forma pode ser representada como uma subdivisão de 
triângulos, ou aproximada, caso seja muito complexa~\cite{hughes2014computer}.
Além disso, triângulos mantém sua integridade de forma sobre a maior parte de 
transformações afins e projeções de perspectiva, e a maior parte dos dispositivos de 
hardware comerciais de aceleração gráfica são otimizados para rasterização de 
triângulos~\cite{gregory2009game}.

\section{Iluminação}

Iluminação em aplicações gráficas consiste na simulação do modelo de iluminação que há 
no mundo real. Existem várias fontes de luzes diferentes e também diferentes tipos de 
luz, por exemplo, uma fonte de luz pode ser unidirecional ou multidirecional.

Objetos que estão mais próximos de uma fonte de luz tendem a ter uma intensidade maior 
das cores presentes em suas superfícies, e quanto mais se distanciam de uma fonte de 
luz, suas superfícies tendem a ficar mais escuras. Além disso, alguns objetos possuem 
materiais que refletem a luz, como o vidro, e também que causam a refração da luz, os 
modelos de iluminação também são capazes de simular estes efeitos. Essa técnica de 
simular intensidades de luz diferentes sobre os objetos através da variação dos níveis 
de escuridão é conhecida como sombreamento.

Existem seis fenômenos principais que surgem da interação entre objetos e iluminação, 
que determinam a coloração modificando ou filtrando a distribuição de energia da luz 
incidente. Estes fenômenos são: reflexão, transmissão, absorção, difração, refração e 
interferência. A maior parte da atenção na área de Computação Gráfica foi dada a modelos 
de reflexão~\cite{Watt2003GVA}.

Há mais de um modelo de reflexão disponível na literatura. Por motivos de eficiência e 
simplicidade, o modelo utilizado para a aplicação deste trabalho será o modelo de 
sombreamento de Blinn-Phong~\cite{Blinn1977MLR}.

\section{Shaders}

Shaders são pequenos programas que são executados na GPU, escritos em uma linguagem de 
\textit{shading}, projetada para tornar a programação dos shaders fácil. 
Esses programas são utilizados para descrever como processar os dados no 
\textit{pipeline} gráfico~\cite{hughes2014computer}. Os dados são enviados da CPU para 
a GPU através de uma API gráfica (ver seção~\ref{lowlevelrenderer}), onde os shaders 
são capazes de referenciá-los e manipulá-los.

Essas linguagens de \textit{shading} lembram vagamente linguagens imperativas 
clássicas, porém contém apenas o necessários para o processamento destes dados na GPU. 
Os shaders utilizados com OpenGL por exemplo, são escritos em uma linguagem conhecida 
como GLSL, acrônimo para \textit{OpenGL Shading Language}~\cite{shreiner2013opengl}.

Há várias operações que os shaders são capazes de realizar sobre os dados na GPU, tais 
como: transformar os vértices dos objetos de um espaço para outro (por exemplo, 
do espaço do objeto para espaço do mundo), sombreamento, utilizar as coordenadas de 
normais para iluminação, \textit{mappings}, utilizar coordenadas de textura para 
aplicar uma certa textura, entre outros.

Existem vários tipos diferentes de shader, cada um é responsável por uma etapa 
diferente do \textit{pipeline} de renderização. A seguir serão listados os diferentes 
tipos de shader, na ordem em que suas funções são realizadas pelo \textit{pipeline} de 
renderização~\cite{shreiner2013opengl}~\cite{hughes2014computer}:
\begin{itemize}
    \item Vertex Shader: responsáveis pela manipulação geométrica dos objetos, realiza 
        transformações das posições dos vértices.
    \item Tessellation Shader: Utiliza descrições de alto nível de superfícies e produz 
        lista de triângulos a partir delas. Pode receber como \textit{input} os vértices 
        e uma estrutura de uma malha, e produzir como \textit{output} uma coleção de 
        triângulos menores que fornecem uma boa aproximação das superfícies da malha.
    \item Geometry Shader: Podem alterar a lista de triângulos a serem processados nas 
        etapas subsequentes. Um uso popular dos \textit{geometry shaders} é para a 
        renderização por camadas~\cite{shreiner2013opengl}.
    \item Fragment Shader: responsável pelo processamento dos fragmentos, que são 
        pedaços de polígonos que vão aparecer em um único pixel. Colocando de outra 
        maneira, os \textit{fragment shaders} irão determinar a cor final de um pixel 
        na tela, por isso neste shader serão computadas interpolações de cores, a 
        iluminação aplicada sobre o vértice e as texturas, se houver alguma.
    \item Compute Shader: neste shader será feito o cálculo de informação arbitrária, 
        geralmente utilizado para tarefas que não estão diretamente relacionadas com a 
        renderização de triângulos ou pixels.
\end{itemize}

Um conjunto contendo cada um desses tipos diferentes de shader é conhecido como 
"programa de shader". Primeiramente um programa de shader deve ser criado, depois disso 
todos os shaders são individualmente carregados, compilados e adicionados a um 
programa de shader. Após essa etapa de compilação, o programa então deve ser ligado à 
GPU e está pronto para ser usado. Uma instrução para explicitamente utilizar um 
programa de shader é necessária antes do processo de renderização ser feito.

Uma aplicação não é restrita a apenas um programa de shader, vários programas podem 
ser criados por aplicação, permitindo o uso alternado destes durante uma execução. 
Isso significa que os objetos presentes na cena podem utilizar um programa de shader 
específico para sua renderização e consequentemente seu método de renderização poderá 
ser diferente de outros objetos.

\section{Renderizador Gráfico de Baixo Nível}
\label{lowlevelrenderer}

O renderizador gráfico de baixo nível é responsável pelos elementos mais técnicos da 
renderização. Sua preocupação é lidar com as primitivas geométricas da maneira o mais 
eficiente possível sem comprometer suas integridades~\cite{gregory2009game}.

Uma de suas funções é lidar com a comunicação entre a aplicação gráfica e a GPU, esta 
estará constantemente recebendo dados da aplicação durante toda a sua execução. Esta 
comunicação é feita através de uma API gráfica, como por exemplo, a API gráfica 
utilizada para o motor de jogos deste trabalho, o OpenGL~\cite{shreiner2013opengl}, 
que apesar de possuir uma vasta quantidade de comandos diferentes para uma rica 
manipulação dos recursos da GPU, geralmente há necessidade de uma grande quantidade de 
código para fazer até mesmo as rotinas mais simples de uma aplicação gráfica. Por isso, 
além de utilizar uma API gráfica, esse componente responsável pela renderização de 
baixo nível também geralmente inclui um \textit{wrapper} para os comandos da API, 
condensando várias funções diferentes em abstrações de maior nível, agilizando o 
desenvolvimento e minimizando a quantidade de erros.

O renderizador de baixo nível também conta com outros componentes, como a gerência da 
matriz de visualização e dos parâmetros da projeção 3D (campo de visão, e as posições 
dos planos de visão). Também gerencia o estado do hardware gráfico e dos shaders e
argumentos que controlam as fontes de luz e as texturas~\cite{gregory2009game}.

\section{O \textit{Pipeline} de Renderização}
\label{renderingpipelinesec}

O pipeline de renderização é o componente núcleo da renderização em tempo real. Ele 
receberá todos os argumentos dos objetos que estão em cena, das câmeras, dos parâmetros 
de projeção, da iluminação, as texturas, equações de sombreamento, entre 
outros~\cite{akenine2008real}.

Um pipeline consiste em várias etapas que geralmente são executadas em sequência para 
gerar um produto final. No caso do pipeline de renderização, para cada um dos ciclos 
feito o produto final é uma imagem renderizada a partir dos argumentos supracitados, essa 
imagem renderizada é chamada de quadro. Quanto mais eficiente for o pipeline e quanto 
maior o poder computacional do hardware, mais rápido esses quadros poderão ser 
renderizados.

Segundo~\cite{akenine2008real}, o pipeline de renderização pode ser dividido em três 
etapas principais: aplicação, geometria e rasterizador, cada uma destas é um pipeline por 
si só. A figura~\ref{renderingpipelinerep} apresenta as três etapas principais e suas 
respectivas subdivisões. A seguir, cada uma destas etapas será discutida separadamente.

\begin{figure}[h]
    \centering
    \captionof{figure}{Representação do pipeline de renderização com suas três etapas 
    principais, estas também estão divididas em suas sub-etapas.}
    \includegraphics[width =.8\textwidth]{../figuras/renderingpipeline}
    \par\medskip
    Disponível em: <http://www.cgchannel.com/2010/11/cg-science-for-artists-part-2-the-real-time-rendering-pipeline/>. 
    Acesso em: 27/05/2017.
    \label{renderingpipelinerep}
\end{figure}

\subsection{Aplicação}

A primeira etapa, a de aplicação, é executada na CPU\@. Esta é a parte a qual o 
desenvolvedor possui total controle, e na qual a maior parte das otimizações podem ser 
feitas para a melhora do desempenho do pipeline. 

Alguns exemplos de computações que são feitas nesse estágio são: gerenciamento de \textit{inputs}, 
detecção de colisão, animações de texturas, animações através de transformações, ajuste 
de parâmetros que são utilizados nas outras etapas, etc. Ao final dessa fase, toda a 
geometria e parâmetros computados são passados à fase de geometria.\ essa passagem de 
dados é considerado o passo mais importante da parte de aplicação.

\subsection{Geometria}

Na etapa de geometria a maior parte das operações sobre vértices e polígonos são feitas. 
Essa etapa ainda é subdividida em outras etapas menores: transformação de modelo e de 
visualização, \textit{vertex shading}, projeção, truncamento e mapeamento para tela. 

A transformação de modelo e de visualização converte o sistema de coordenadas de um 
vértice para coordenadas do mundo e coordenadas de visualização, respectivamente conforme 
visto na seção~\ref{viewingpipelinesec}.

O \textit{vertex shading} é o processo pelo qual todos os vértices da cena passam e nessa 
parte serão definidas suas cores, posições, texturas, quantidade de iluminação e outros 
atributos. Todos esses atributos são então enviados para a etapa de rasterização onde 
serão interpolados.

Na etapa de projeção, ocorre uma transformação do volume de visualização, e o seu formato 
dependerá do tipo de projeção utilizada, alterando a percepção dos objetos da cena. 
Conforme discutido na seção~\ref{viewingpipelinesec}, a projeção utilizada neste trabalho 
é a projeção perspectiva, que transforma o volume de visualização em uma pirâmide 
truncada, chamada de \textit{frustum} de visualização, na qual os objetos mais próximos 
da base da pirâmide aparentam ser menores.

A etapa de truncamento serve para truncar os objetos da cena que estão sendo parcialmente 
vistos no volume de visualização. Objetos que possuem alguns vértices dentro e outros 
fora do volume de visualização precisam ter seus vértices que estão fora realocados para 
os extremos do volume de visualização.

Na última sub-etapa, a de mapeamento para tela, as coordenadas das primitivas truncadas 
dentro do volume de visualização são transformadas para a tela. As coordenadas $x$ e 
$y$ de cada primitiva são transformadas para formar as coordenadas da tela. As coordenadas 
de tela combinadas com as coordenadas $z$ são chamadas de coordenadas de janela. É nessa 
etapa que as coordenadas são essencialmente convertidas de tridimensionais para 
bidimensionais.

\subsection{Rasterização}

Com todos os dados para o devido \textit{shading} do objeto, nessa etapa as cores dos 
pixels são computadas e definidas, esse é o processo conhecido como rasterização, que é 
a conversão dos vértices em coordenadas de janela juntamente com a informação de 
\textit{shading} para pixels desenhados na tela.
Assim como a etapa de geometria, a etapa de rasterização também é dividida em sub-etapas, 
que são: configuração dos triângulos, \textit{triangle traversal}, \textit{pixel shading} 
e combinação.

Na etapa de configuração dos triângulos, os dados sobre as superfícies dos triângulos 
são computados. Esses dados são utilizados para a interpolação de várias informações 
de \textit{shading} produzida na etapa de geometria. Etapa feita por operações fixas 
do hardware dedicado para essa parte.

Na etapa de \textit{triangle traversal} são procurados os pixels que estão dentro de 
um triângulo, ou seja, que pertencem ao plano formado pelos três vértices de um dos 
triângulos presentes na tela. Para cada um dos pixels encontrados é gerado um 
fragmento. As propriedades dos fragmentos de cada triângulo são geradas utilizando 
dados interpolados entre os três vértices.

No \textit{pixel shading}, são feitas todas as computações de \textit{shading} pixel 
por pixel, usando os dados interpolados como \textit{input}, resultando em uma ou mais cores 
para serem passadas à próxima etapa. Esta etapa, ao contrário das outras que são 
feitas por funções fixas do hardware dedicado, é feita por núcleos programáveis da 
GPU, nomeadamente pelo \textit{fragment shader}. Esse shader será responsável por 
aplicar texturas, iluminação, entre outros em cada um dos fragmentos.

Por fim, na combinação a informação de cada pixel é armazenada em um \textit{buffer} 
de cores, que contém cada um dos componentes RGB da cor final. A unidade da GPU 
responsável por essa etapa não é completamente programável, porém altamente 
customizável.
A cor resultante da etapa anterior (\textit{pixel shading}) é combinada com a cor 
atualmente armazenada no \textit{buffer}.

Essa etapa também é responsável por resolver a visibilidade, ou seja, armazenar no 
\textit{buffer} de cores somente as cores das primitivas que estão visíveis a partir 
do ponto de vista da câmera. Para a maior parte dos hardwares gráficos, isso é feito com 
o algoritmo do \textit{Z-buffer}. Esse algoritmo foi originalmente proposto por Edwin 
Catmull~\cite{Catmull1974}, seu funcionamento consiste no uso de um \textit{buffer} de 
profundidade, disposto em uma matriz bidimensional que armazena a profundidade de cada 
um dos pixels da tela. Quando um objeto precisa ser renderizado em um pixel já 
utilizado, o método compara as duas profundidades e caso o novo objeto esteja mais 
próximo do observador, o pixel é então sobrescrito por este objeto e o novo valor de 
profundidade substitui o antigo no \textit{buffer}.

Todos os \textit{buffers} combinados formam o chamado \textit{frame buffer}, que em 
consequência contém toda a informação de um quadro de uma cena renderizada. A tela exibe 
os conteúdos do \textit{buffer} de cores.

\section{O \textit{Loop} de Jogo}
\label{gameloopsec}

O \textit{loop} do jogo é onde os componentes funcionam em conjunto para proporcionar o que 
define um jogo: uma aplicação interativa em tempo real. 
Sistemas interativos em tempo real podem ser divididos em três módulos principais: 
recebimento de \textit{inputs}, processamento e apresentação dos 
resultados~\cite{dalmau2004core}.

Jogos possuem restrições de tempo para realizar todas as 
suas rotinas, se o sistema não for capaz de fazer seu trabalho dentro do limite de 
tempo irá falhar. Uma vez que sistemas em tempo real são supostos fazer suas tarefas 
em tempo real, se um jogo não for capaz de fazer isso, o usuário (nesse caso o 
jogador) não receberá um \textit{feedback} contínuo, e o jogo não fornecerá a 
interatividade que deveria. Um \textit{loop} de jogo pode ser implementado com a 
finalidade de satisfazer essas restrições~\cite{Joselli2010}.

Nos jogos eletrônicos, o sistema de \textit{inputs} corresponde ao gerenciamento do dispositivo 
de \textit{inputs}, como mouse, teclado ou controlador de jogo; o processamento é responsável 
por tomar as decisões que afetam o estado do jogo, e a apresentação é responsável por 
mostrar os resultados desses dois outros estágios, através de áudio e 
vídeo~\cite{valente2005real}. 

Elaborar um \textit{loop} de jogo significa organizar esses três módulos, e seus submódulos na 
certa para deixar a simulação o mais fiel o possível da experiência desejada. 
Considerando os módulos citados, o \textit{loop} do jogo pode ser dividido da seguinte 
maneira:
\begin{itemize}
    \item Detecção e gerenciamento de \textit{inputs}
    \item Estágio de processamento
    \item Estágio de apresentação
\end{itemize}

O estágio de processamento é ainda subdividido em outras partes, onde cada uma 
corresponde a um aspecto diferente do estado do jogo, como detecção de colisões, 
simulações físicas, a IA do jogo, aplicações das regras do jogo, etc. Estas portanto, 
também devem ser organizadas na ordem correta. No estágio de apresentação são 
reproduzidos todos os áudios necessários e a cena é renderizada na tela com os 
resultados dos estágios anteriores.

Uma medida de desempenho de aplicações gráficas que também é utilizada para medir a 
frequência com a qual esses \textit{loops} são executados é a quantidade de quadros por 
segundo (\textit{Frames per Second}) que são renderizados na tela, conhecido como 
FPS. Cada quadro que aparece na tela representa uma imagem construída e apresentada 
pela aplicação.

O desempenho de um jogo, além de ser dependente das otimizações feitas a nível de 
software, é também dependente da configuração de hardware da plataforma na qual será 
executado. Portanto, um mesmo jogo pode rodar com um FPS diferente dependendo da 
plataforma utilizada, visto que a atualização do estado do jogo é dependente da 
quantidade de quadros construídos, uma mesma sequência de eventos pode ter um 
resultado diferente dependendo do poder computacional do hardware. 

Para evitar esse problema, é necessário tornar o estágio de processamento independente 
da taxa de FPS. Isso pode ser feito adicionando um parâmetro de tempo ao estágio de 
processamento. Esse parâmetro corresponde ao tempo decorrido entre a atualização 
atual e a última atualização do processamento feita~\cite{valente2005real}, e é 
conhecido como \textit{delta time}, indicando uma diferença de tempo.

Além da separação do estágio de processamento em sub-tarefas, é importante salientar 
que nem todas possuem a mesma necessidade de atualização que outras. Por exemplo, a IA 
não precisa ser atualizada com a mesma frequência que a simulação física, 
é necessário somente quando um agente precisa tomar uma decisão. A renderização por 
outro lado, proporcionará um resultado melhor quanto mais atualizada esta for, desde 
que não comprometa o desempenho geral do sistema. Por isso, uma forma de otimizar o 
desempenho é atualizar cada um dos componentes somente quando necessário.

\section{Interpolações}

Na seção~\ref{gameloopsec}, foi discutido o problema da atualização do estado do jogo em 
relação à taxa de quadros por segundo com a qual a aplicação está sendo executada, e 
como esse problema podia ser solucionado adicionando um parâmetro que indicasse o tempo 
decorrido entre o último quadro e o atual.

Interpolação é um dos recursos utilizados na solução deste problema, e é utilizada para 
qualquer caso em que se queira passar uma noção de locomoção ou movimento entre os 
diversos quadros, seja através de animações, aplicação de forças, rotações, etc.

Caso se queira adicionar um vetor de velocidade a um objeto, esse objeto passará a ter 
duas velocidades: a velocidade inicial, a qual ele já possui, e a velocidade alvo, a qual 
é uma combinação de sua velocidade inicial com a nova velocidade aplicada. Se a alteração 
da velocidade inicial para a velocidade alvo fosse feita de um quadro para o outro, o 
objeto teria uma aceleração instantânea (ou desaceleração) completamente não natural e 
não realista. A interpolação serve para calcular os pontos intermediários entre esses 
dois extremos a partir de um parâmetro que determinará quantos pontos intermediários 
serão gerados. No exemplo da velocidade, esse parâmetro pode ser uma combinação entre 
uma aceleração e o tempo decorrido entre um quadro e outro (\textit{delta time}). Dessa 
maneira, a alteração da velocidade será feita de uma maneira gradual e independente da 
taxa de quadros por segundo.

A classe geral de funções utilizadas para interpolações são chamadas de curvas 
paramétricas. Dado os dois pontos sendo interpolados, uma interpolação entre estes 
pode ser entendida como uma curva formada entre suas posições, onde o parâmetro 
supracitado determinará em que posição se está nessa curva. O exemplo mais simples de uma 
curva paramétrica é dado por:

\begin{equation}
    \begin{aligned}
        L(t) = 1 - t \cdotp P_0 + t \cdotp P_1
    \end{aligned}
\end{equation}

\vspace{1cm}

Esta é uma interpolação linear, onde $L(t)$ é um ponto intermediário, $P_0$ é o ponto 
inicial, $P_1$ é o ponto alvo e $t$ é o parâmetro utilizado para controlar a posição em 
que se está na linha relativa a $P_0$ e $P_1$. Nota-se que $t$ varia em um intervalo 
entre $[0,1]$, quanto mais próximo de $0$, mais próximo de $P_0\ $ se estará e quanto 
mais próximo de $1$ mais próximo de $P_1\ $ se estará. 

Esse conceito de interpolação linear pode ser estendida para vetores e quaternions por 
exemplo, permitindo a aplicação gradual de forças e de rotações.
Na área de Computação Gráfica, é popular a utilização do jargão "lerp"\ para se referir 
à interpolação linear, uma abreviação de \textit{Linear Interpolation}.

\subsection{Interpolação Entre Vetores}

A interpolação linear entre dois vetores é semelhante à interpolação entre dois pontos 
vista anteriormente. A diferença é que o cálculo da interpolação é feito componente a 
componente, semelhante às outras operações entre dois vetores:

\begin{equation}
    \begin{aligned}
        Lerp(u,v,t) = (1 - t \cdotp u_x + t \cdotp v_x, \\
                      1 - t \cdotp u_y + t \cdotp v_y, \\
                      1 - t \cdotp u_z + t \cdotp v_z)
    \end{aligned}
\end{equation}

\vspace{1cm}

\subsection{Interpolação Entre Quaternions}

Para interpolar dois quaternions, é necessário calcular o menor caminho do ângulo formado 
entre os dois, visto$\ $ que a interpolação é feita de maneira circular. Para realizar este 
cálculo, utiliza-se o produto escalar entre os dois quaternions, que retornará o cosseno 
do ângulo e dependendo do seu valor, parâmetros diferentes são utilizados:

\begin{equation}
    \begin{aligned}
        \cos \theta = q_1 \cdotp q_2 \\
        t_1 = 1 - t \\
        q_i = 
        \begin{cases}
            (q_1 \cdotp t_1) + (q_2 \cdotp t) & \quad \text{se } \cos \theta > 0 \\
            (q_1 \cdotp t_1) + (q_2 \cdotp -t) & \quad \text{se } \cos \theta < 0 \\
        \end{cases}
    \end{aligned}
\end{equation}

\vspace{1cm}

Onde $q_1$ e $q_2$ são os dois quaternions sendo interpolados, $t$ é o parâmetro de 
interpolação e $q_i$ é o quaternion resultante da interpolação. É importante ressaltar 
que $q_i$ deve ser normalizado ao final da interpolação.

Quaternions ainda possuem um outro tipo de interpolação, a interpolação linear esférica, 
que é um pouco mais custosa de se calcular do que a interpolação linear normal, porém 
possui uma precisão maior. Essa interpolação é conhecida como "slerp", abreviação de 
\textit{Spherical Linear Interpolation}. Utilizando os mesmos parâmetros da outra 
interpolação, a slerp é dada por:

\begin{equation}
    \begin{aligned}
        \theta = \arccos(q_1 \cdotp q_2) \\
        t_1 = \sin((1 - t) \cdotp \theta / \sin \theta) \\
        t_2 = \sin(t \cdotp \theta / \sin \theta) \\
        q_i = (t_1 \cdotp q_1) + (t_2 \cdotp q_2)
    \end{aligned}
\end{equation}

\vspace{1cm}

Assim como na interpolação linear normal, aqui $q_i$ também deve ser normalizado ao final 
da operação.

\section{Considerações Finais do Capítulo}

Neste capítulo foram apresentados os fundamentos utilizados para o desenvolvimento do 
trabalho proposto, que possui um alto fator interdisciplinar.
A modelagem orientada a dados é um termo que surgiu recentemente, porém seu conceito de 
uso eficiente e sequencial da memória já é utilizado a mais tempo. Foram apresentados 
alguns de seus principais princípios, suas diferenças com a programação orientada a 
objetos, que atualmente é considerada o padrão na indústria, e como a restruturação de 
código utilizando essa abordagem pode proporcionar uma melhora no desempenho de uma 
aplicação.

Os motores de jogos revolucionaram o modo como os jogos são feitos na indústria através 
da clara separação entre o conteúdo técnico e o criativo de um jogo. Foi explicado o 
surgimento deste conceito, a filosofia de implementação de um motor de jogo, a 
importância da integração apropriada de seus componentes e também foram apresentados 
alguns exemplos de componentes comuns em motores de jogos.
Foram apresentados diversos conceitos matemáticos que são amplamente utilizados na 
área de computação gráfica, e também as diferentes estruturas comumente utilizadas e 
suas respectivas funcionalidades e métodos.

Foram apresentados os \textit{pipelines} de visualização e renderização, dois 
conceitos importantes em aplicações gráficas que consistem em etapas que processam os 
dados desde o seu carregamento no sistema até serem transformados em pixels na tela, 
e como o renderizador gráfico de baixo nível auxilia nas etapas da renderização.
Outros conceitos importantes de Computação Gráfica também foram explicados, como 
\textit{shaders}, iluminação e malhas de polígono.

Todos os componentes são combinados para a formação de um \textit{loop} principal, que será 
encarregado de receber e gerenciar os \textit{inputs} do jogador, atualizar os 
componentes que necessitam fazê-lo, e apresentar os resultados computados. Esse \textit{loop} 
é conhecido como \textit{loop} de jogo, neste capítulo esse conceito foi introduzido e detalhado.
Também foi discutido sobre alguns de seus problemas, como a necessidade de diferentes 
frequências de atualização de cada um dos componentes, e também como os resultados 
das atualizações podem ser diferentes dependendo do poder computacional do hardware 
utilizado. Foi apresentada uma solução para este problema, e também uma medida de 
desempenho popular para jogos, a taxa de quadros por segundo (FPS).

Por fim, foi apresentado o conceito de interpolações e como o seu uso se relaciona com 
o problema da variação de FPS em jogos. Além disso, foram apresentados exemplos de 
implementação da interpolação linear para vetores e quaternions.

\chapter{Trabalhos Relacionados}
\label{relatedworkscap}

Neste capítulo serão apresentados alguns trabalhos encontrados na literatura que estão relacionados 
com a proposta deste trabalho. A maioria dos trabalhos apresentados concentra-se em criar 
funcionalidades únicas para um motor de jogos e também nas melhores práticas para o 
desenvolvimento de motores de jogos, porém nenhum destes trabalhos explora o uso da 
modelagem orientada a dados.
Apesar de nenhum deles estar diretamente relacionado com a proposta deste trabalho, os 
autores também tinham como um dos objetivos desenvolver um motor de jogos eficiente e 
bem estruturado.

\citeonline{deFreitas2012GEC} propôs um modelo de motor de jogos com uma 
arquitetura baseada em componentes, na qual as entidades do jogo são definidas através 
da agregação de componentes, em contraste com os modelos clássicos os quais utilizam 
hierarquia de classes e heranças múltiplas, que leva a problemas como forte 
interdependência das entidades, conflito de nomenclaturas e heranças repetidas.

Esta arquitetura baseada em componentes atualmente é utilizada em motores de jogos 
comerciais populares, como é o caso do motor de jogos de propósito geral 
Unity3D\footnote{Site do Unity3D: https://unity3d.com}. Nesse 
modelo, uma entidade pode ter características diferentes adicionadas a ela através da 
adição de componentes configuráveis, como um componente renderizador de imagens, um 
reprodutor de áudios, um corpo suscetível à aplicação de forças físicas, entre outros. 
Este modelo de arquitetura permite então a criação de entidades com uma maior 
flexibilidade, adaptabilidade e independência, além de não apresentar os problemas do 
uso de herança.

O trabalho deles prossegue então, para explicar seus diferenciais, como a utilização de 
entidades que permitem a sua reconfiguração dinâmica em diferentes 
momentos da aplicação. Consequentemente isso permite flexibilidade e extensibilidade 
até mesmo em tempo de execução. Por fim eles apresentam as decisões de design que os 
permitiram atingir esses objetivos.

\citeonline{Anderson2008} discute em seu trabalho alguns problemas ainda pendentes 
em se tratando de desenvolvimento de motores de jogos, e incentiva a pesquisa no campo 
de arquitetura e design de motores de jogos. 

Primeiramente, os autores comentam sobre o aumento significativo do uso motores de 
jogos, pelo aumento da produtividade que estes proporcionam. Depois é mencionada a falta 
de literatura e pesquisa a respeito de modelagem e arquitetura de motores de jogos em 
geral, sendo que a maioria do material encontrado tem ênfase apenas na implementação dos 
componentes individuais, enquanto que as estratégias utilizadas para a modelagem dos 
motores como um todo não são comentadas, sendo então difícil encontrar material que 
apresente uma explicação minuciosa sobre a modelagem e estruturação da arquitetura de 
um motor de jogos.

Depois dessa introdução, são mencionados alguns problemas persistentes nessa área, que 
podem ser potenciais áreas de pesquisa a respeito de motores de jogos. Primeiramente,
são: há uma falta de convenção sobre as terminologias utilizadas em desenvolvimento de 
jogos, frequentemente levando a problemas de comunicação e pesquisa eficiente e confusão 
entre os estudantes novos na área. 

O segundo problema mencionado é a dificuldade na determinação do limite entre o que faz 
parte do jogo propriamente dito e o que faz parte do motor de jogos. Não há uma 
definição concreta sobre o que é um motor de jogos e existem várias versões diferentes, 
frequentemente levando ao equívoco no entendimento sobre o conceito de um motor de 
jogos. 

O terceiro problema mencionado é sobre as decisões de modelagem do motor de jogos, e 
como diferentes gêneros de jogos afetam essas decisões, pois algumas estratégias em 
específico beneficiam somente uma certa classe de jogos. É levantada então a 
questão da possibilidade de definição de um motor de jogos que é eficiente para qualquer 
jogo independente do seu tipo.

O quarto problema mencionado é sobre o impacto que as rotinas de baixo-nível dos motores 
de jogos causam na modelagem de alto-nível do mesmo, comentando sobre a constante 
evolução da tecnologia utilizada em dispositivos de hardware ou nas interfaces do 
software e suas capacidades, e como essas mudanças podem afetar a evolução de um ou 
múltiplos componentes do motor de jogos.

O último problema mencionado é sobre as melhores convenções e práticas de programação 
que devem ser utilizadas na modelagem de um motor de jogos. Como os motores de jogos 
estão em constante crescimento e evolução desde seus desenvolvimentos iniciais, a 
adição de novas funcionalidades pode ser problemática ou até mesmo impossível, se os 
objetivos no motor de jogos não foram bem definidos no início do projeto, ou se sua 
arquitetura não foi bem estruturada. Os autores ponderam então se existe um conjunto de 
melhores práticas para evitar ou reduzir estes problemas.

\citeonline{Keenan2011} salientam a importância da definição de uma boa arquitetura para 
o desenvolvimento de um motor de jogos. Em seu trabalho, ele menciona os problemas 
relacionados com a má estruturação do motor de jogos, e como a criação de um sistema 
flexível e modularizado pode evitar esses problemas, além de proporcionar outras 
vantagens.
Como o seu trabalho é para fins educativos, o restante do artigo trata sobre a 
criação de um curso sobre arquitetura de jogos, no qual o foco não é a implementação dos 
componentes separados do motor de jogos, mas sim a utilização das melhores práticas de 
programação e modelagem para a construção de um motor de jogos com uma arquitetura 
robusta.

\citeonline{Zhu2016ECG} propõem uma nova metodologia para o desenvolvimento de jogos, 
chamada de \textit{Engine- Cooperative Game Modeling} (ECGM), um modelo híbrido 
que combina duas outras metodologias: \textit{Model-Driven Game Development} (MDGD) e a 
cadeia de ferramentas do motor de jogos, com ênfase nos aspectos técnicos. A motivação 
de seu trabalho é que nenhuma das abordagens para o MDGD na literatura demonstrou 
convincentemente uma boa integração do MDGD com a cadeia de ferramentas do motor de 
jogos.
No restante do trabalho, é descrito o funcionamento desta metodologia proposta, e como 
ela pode fornecer uma melhoria na modelagem dos projetos ao utilizar o MDGD levando em 
consideração a cadeia de ferramentas tipicamente utilizadas em motores de jogos.

Um trabalho mais relacionado ao tema modelagem orientada a dados é o proposto 
por~\citeonline{Fontana2017}, no qual a MOD é utilizada no desenvolvimento de uma 
ferramenta \textit{opensource} de projeto físico de circuitos integrados. No trabalho 
são discutidos os principais conceitos da MOD, como esta pode ser utiliada para aprimorar 
a qualidade do \textit{software} e como pode ser utilizada no contexta de porblemas de 
projeto físico, que assim como jogos, também precisa lidar com uma substancial quantidade 
de dados.

Para validar os fundamentos discutidos, foi desenvolvido um sistema utilizando um padrão de 
projeto conhecido como modelo entidade-componente, que consiste em decompor um problema 
em um conjunto de entidades e seus componentes (chamados de propriedades). Os resultados 
obtidos foram comparados com um outra sistema com uma abordagem orientada a objetos para 
testas o desempenho do sistema com MOD.\@ As métricas escolhidas foram o tempo de execução e 
a quantidade de \textit{cache misses} para dois problemas diferentes. 

Os resultados obtidos pelos autores mostram que um problema em um cenário com boa 
localidade de data, isto é, cenários que requerem poucas propriedades de cada entidade, a 
MOD é cerca de 90\% mais rápida que a orientação a dados. Enquanto que em um cenário com 
uma má localidade de data, que requer o acesso a uma quantidade superior de propriedades 
diferentes das diferentes entidades do sistema, a MOD apresenta um desempenho apenas 6\% 
pior em média.

\section{Considerações Finais do Capítulo}

Dados os problemas mencionados nos trabalhos relacionados, percebe-se que a maior 
dificuldade no desenvolvimento de um motor de jogos não consiste na implementação dos 
componentes individuais que compõem o motor, mas sim na integração adequada destes 
componentes e no projeto e modelagem eficientes do motor. 

Como foi mencionado, a maior parte do material encontrado concentra-se na implementação 
dos componentes individuais e nas otimizações feitas sobre estes, como por exemplo as 
otimizações que podem ser feitas em algoritmos de inteligência artificial comumente 
utilizados em jogos. Como a proposta deste trabalho se concentra exatamente em uma 
abordagem diferente para a modelagem e estruturação dos componentes do motor de jogos 
e consequentemente na integração destes, foi possível encontrar trabalhos apenas 
parcialmente relacionados.

Além disso nenhum dos trabalhos encontrados deu ênfase nos problemas que podem surgir 
do uso da programação orientada a objetos em jogos, e quais são as alternativas ou 
práticas que podem contornar esses problemas. Apesar de alguns trabalhos mencionarem 
maneiras de melhorar a arquitetura e projeto de um motor de jogos, ou proporcionar 
uma maior flexibilidade e extensibilidade, nenhum deles discute sobre como melhorar a 
estrutura desses componentes, principalmente levando em consideração a evolução do 
hardware, conforme mencionado por Anderson~\cite{Anderson2008}.

Devido ao fato da modelagem orientada a dados ainda não ser um conceito muito difundido, 
não foi possível encontrar trabalhos que tivessem ênfase especificamente neste tópico.

\chapter{Otimizações para motores de jogos através de modelagem 
orientada a dados}
\label{proposalcap}

Para testar as otimizações proporcionadas pela modelagem orientada 
a dados, um motor de jogos foi desenvolvido em duas versões 
diferentes: uma utilizando os conceitos da programação orientada a 
objetos, e outra utilizando modelagem orientada a dados,
visando à otimização da comunicação entre o processador e a memória.
Além de utilizar os conceitos da MOD, também é necessário 
utilizar conceitos de Computação Gráfica, Álgebra Linear e Geometria Analítica, Teoria 
de Grafos, Processamento de Imagens, Física, entre outros.

Conforme explicado na seção~\ref{secgameengine}, um motor de jogos é uma combinação de 
diversos componentes diferentes que juntos compõem a parte lógica de um jogo digital. As 
seções seguintes discutirão sobre os componentes implementados que foram julgados 
necessários para o desenvolvimento do motor de jogos que é o objeto de estudo deste 
trabalho, bem como as diferenças entre as implementações.

Além dos componentes, também serão explicadas as estratégias empregadas para a 
implementação de outros elementos importantes discutidos previamente no 
capítulo~\ref{theorycap} que fazem parte da estrutura de um motor de jogos, como o 
\textit{pipeline} de renderização e o loop de jogo.

Como um motor de jogos por si só não é suficiente para se gerar análises e resultados, 
pois seu objetivo é dar suporte ao desenvolvimento de uma outra aplicação, além do 
desenvolvimento do motor, foi necessário o desenvolvimento de uma aplicação 
que utilize as funcionalidades do motor para realmente 
verificar sua eficiência. A aplicação desenvolvida é idêntica para 
as duas versões do motor.

A análise de desempenho das principais funções da aplicação 
permitirá a comparação entre as duas abordagens e a eficiência da 
MOD. Além das alterações necessárias nos componentes do motor, há 
também alterações a serem feitas na aplicação de teste 
desenvolvida, estas serão apresentadas para demonstrar a conversão 
entre as abordagens. Apesar das diferenças, nem todos os componentes 
sofreram alterações entre as duas versões, por este motivo não 
serão apresentadas alterações para todos os componentes descritos 
nesse capítulo.

\begin{figure}[h]
    \centering
    \captionof{figure}{UML simplificado contendo os principais componentes do motor.}
    \includegraphics[width =.8\textwidth]{../figuras/uml_engine}
    \par\medskip
    Fonte: autoria própria
    \label{umlengine}
\end{figure}

A figura~\ref{umlengine} contém um diagrama de classes com as principais
classes do motor e as relações entre estas na versão orientada a objetos. Os 
componentes do motor juntos contém o mínimo necessário para executar uma 
aplicação gráfica 3D utilizando openGL. O componente gráfico é composto pelas 
classes ProgramaShader, GrafoCena, NoGrafo, Camera e Malha. O componente da 
física é composto pela classe Objeto. 

Para o gerenciador de recursos foi 
utilizado o padrão de \textit{singletons} de design de software, no qual as 
classes que são \textit{singletons} restringem a instanciação de objetos da 
classe para exatamente um. As classes do tipo Manager apresentadas na 
figura~\ref{umlengine} são \textit{singletons} que controlam o armazenamento e 
acesso aos principais recursos da aplicação, que são as malhas, objetos, grafos 
de cena, cameras e shaders.

O primeiro passo feito para realizar a conversão do motor para uma abordagem 
orientada a dados, conforme descrito na sessão~\ref{secdataorienteddesign}, 
foi analisar o fluxo de dados necessário para que cada um dos componentes 
funcionem apropriadamente, e especificar quais são os dados gerados 
por cada componente. Depois de determinar o fluxo, o próximo passo foi 
descrever as transformações de dados que cada componente precisa 
realizar.

Após analisar os componentes do motor e a aplicação desenvolvida, 
pode-se observar que o fluxo de dados ocorre na seguinte ordem:\\
\begin{enumerate}
    \item Os recursos externos são carregados no sistema (\textit{shaders} e malhas).
    \item Os objetos e o grafo de cena são criados e alocados.
    \item Inicia-se o ciclo principal do programa:
        \begin{enumerate}
           \item Atualização dos objetos.
           \item Verificação de colisões.
           \item A câmera atualiza a matriz de visualização e projeção.
           \item O grafo de cena é renderizado.
        \end{enumerate}
\end{enumerate}

Com o fluxo de dados definido, é necessário analisar as 
transformações necessárias dos dados. A parte relevante do 
sistema a ser analisada é o ciclo principal, pois é a única parte 
do fluxo de dados que será executada em tempo real.

A primeira etapa do ciclo principal é a atualização dos objetos. 
Primeiramente a aceleração do objeto é atualizada através de 
fórmulas arbitrárias, posteriormente a velocidade é atualizada 
utilizando a aceleração. Com a velocidade atualizada a última 
parte é atualizar a translação e a rotação, ambas são atualizadas 
através da velocidade.

A segunda etapa é a verificação de colisões, isso é feito 
utilizando as dimensões de uma caixa retangular e o componente 
de translação do objeto. O procedimento de verificação de colisão 
simplesmente testa se o componente de translação do objeto não 
ultrapassa as bordas da caixa.

A terceira etapa consiste na atualização das matrizes de 
visualização e projeção da cena. A atualização ocorre somente uma 
vez por frame, e como há somente uma câmera na cena, essa etapa 
não possui muito potencial para otimização.

A última etapa é a renderização do grafo de cena. Para cada nó 
presente no grafo, essa etapa é 
dividida em três partes: cálculo das coordenadas do objeto, 
conversão dessas coordenadas para coordenadas do mundo, e a 
renderização do grafo.

O cálculo das coordenadas do objeto é feito 
através da multiplicação entre a translação, rotação e escala do 
objeto atribuído ao nó. A conversão das 
coordenadas do objeto para as coordenadas do mundo é feita utilizando 
as coordenadas do objeto e a hierarquia do grafo de cena. Por fim 
a última parte é a renderização propriamente dita, na qual não 
há processamento de dados, somente chamadas de métodos da API do 
openGL sobre dados já processados. Os dados necessários para a 
renderização de um nó são a malha atribuída ao objeto deste nó, 
o programa de shader atribuído ao nó e as coordenadas convertidas.

Com o fluxo de dados definido, assim como as transformações sobre 
os dados necessárias, é possível determinar quais são os dados 
mínimos necessários para a execução de aplicação e como 
agrupá-los.

Seguindo a premissa da MOD de descrever as transformações de 
dados sempre para o caso mais provável, as estruturas de dados 
utilizadas para o motor na versão orientada a dados foram 
feitas considerando que em uma aplicação sempre haverá 
várias instâncias de \textit{shaders}, malhas, objetos 
e nós do grafo de cena.

\begin{figure}[h]
    \centering
    \captionof{figure}{Estruturas utilizadas na verão orientada a dados do motor.}
    \includegraphics[width =.8\textwidth]{../figuras/dodengine}
    \par\medskip
    Fonte: autoria própria
    \label{dodengine}
\end{figure}

A figura~\ref{dodengine} apresenta as estruturas utilizadas no ciclo principal de 
execução da aplicação com uma abordagem orientada a dados. As classes de programa de 
shader e malha foram separadas em duas partes: interfaces para a criação de shaders 
e malhas a partir de arquivos externos, e estruturas simples contendo somente dados 
primitivos utilizados no ciclo principal. As estruturas de nós e objetos possuem 
\textit{containers} de $N$ elementos para os atributos principais das respectivas 
classes da versão orientada a objetos. A classe de objeto foi dividida em duas 
estruturas: uma para os dados da matriz de transformação (translação, rotação e 
escala), e a outra para dados de física (velocidade e aceleração).

Cada entidade no sistema possui seu identificador único representado 
por um número inteiro positivo e seus atributos são espalhados pelas estruturas 
que contém \textit{containers}. Ou seja, a referência ao item $0$ 
de qualquer um dos \textit{containers} apresentados na 
figura~\ref{dodengine} refere-se à mesma entidade. Através desse 
ID único de uma entidade os componentes são capazes de transformar 
e mover os dados entre si.

A seguir serão descritos com detalhes os componentes um a um 
presentes nos motores implementados. Para os componentes que 
possuem diferenças de implementação entre as duas versões também 
serão discutidas quais foram as mudanças necessárias para o 
desenvolvimento da versão orientada a dados.

\section{Biblioteca Matemática}

Utilizando os conceitos discutidos na seção~\ref{secmathconcepts}, foi 
desenvolvido uma biblioteca matemática o mais minimalista o possível, contendo somente 
as estruturas e funções necessárias para se realizar os testes e obter os resultados 
desejados deste trabalho. 

A biblioteca é uma das partes do motor mais extensivamente utilizada pois uma 
considerável parcela dos componentes necessitam de sua utilização. Além disso, todas as 
malhas e outros dados que são enviados aos \textit{shaders} programáveis são armazenados em 
estruturas dessa biblioteca, como as matrizes de transformação, visualização e projeção, 
fontes de luz, texturas, etc.

A biblioteca possui três estruturas: vetores, matrizes e quaternions. Para cada uma das 
estruturas há diversas funções diferentes associadas a elas. Além das funções associadas 
às estruturas, existem também funções e utilidades que não são inerentes a nenhuma delas, 
somente da biblioteca em si. 

Para todas as estruturas, o tipo das variáveis utilizadas são os números reais, mais 
especificamente, ponto flutuante de precisão simples. A precisão simples é a utilizada em 
jogos ou outras aplicações gráficas pois geralmente esse nível de precisão já é o 
suficiente, além de ter os benefícios de consumir menos memória e realizar operações 
aritméticas com mais eficiência do que pontos flutuantes de precisão 
dupla~\cite{Verth:2008}.

\subsection{Vetores}

Para os vetores, há uma estrutura separada para os vetores 3D e para os 4D. Os vetores 
2D não estarão presentes na biblioteca pois não terão uso para a aplicação pretendida.

Além do acesso individual a cada um dos componentes do vetor e sua manipulação direta, 
as seguintes funções são suportadas para vetores:
\begin{itemize}
    \item Operações aritméticas: adição e subtração entre vetores, multiplicação ou 
        divisão por escalar e igualdade entre vetores.
    \item Cálculo da magnitude de um vetor.
    \item Magnitude ao quadrado: essa função é similar à magnitude, com a diferença de 
        que essa função não calcula a raiz quadrada da soma dos quadrados dos 
        componentes. Caso a finalidade do cálculo da magnitude seja apenas para comparar 
        dois vetores, esse função já basta, e é mais eficiente pois poupa o cálculo 
        custoso da raiz quadrada.
    \item Normalização: existe duas funções diferentes, uma delas apenas normaliza o 
        vetor, enquanto a outra mantém o vetor inalterado e retorna a sua versão 
        normalizada.
    \item Produto escalar entre dois vetores.
    \item Produto vetorial entre dois vetores. Essa função é exclusiva para vetores 
        3D.
    \item Interpolação linear entre dois vetores.
\end{itemize}

\subsection{Matrizes}

Assim como os vetores, as matrizes também possuem uma estrutura separada para matrizes 
$3 \times 3$ e $4 \times 4$, porém somente esses dois tipos de matrizes quadradas estão 
presentes pois são as únicas necessárias para a implementação da aplicação.

As matrizes possuem suporte à acesso individual a cada elemento e também a manipulação 
direta destes. Além disso, possuem as seguintes funcionalidades:
\begin{itemize}
    \item Adição, subtração e igualdade entre matrizes.
    \item Multiplicação por escalar.
    \item Cálculo da matriz transposta.
    \item Multiplicação entre matrizes.
    \item Multiplicação entre uma matriz e um vetor. Essa função trata o vetor como uma 
        matriz linha ou matriz coluna, dependendo da ordem. Essa função requer uma 
        implementação diferente para cada uma das duas possibilidades de ordem dos 
        operandos.
    \item Cálculo da matriz inversa e do determinante da matriz. Essas duas funções são 
        exclusivas para matrizes $3 \times 3$.
\end{itemize}

\subsection{Quaternions}

Só há uma estrutura para os quaternions, com acesso aos seus componentes escalar $t$, e 
ao vetorial $x,y,z$. Um quaternion pode ser construído tanto passando o valor dos seus 
quatro componentes, quanto passando um ângulo e um eixo, útil para se fazer uma 
transformação de rotação.

A estrutura de quaternion possui as seguintes funcionalidades associadas:
\begin{itemize}
    \item Adição, subtração e igualdade entre quaternions.
    \item Multiplicação por escalar.
    \item Multiplicação entre quaternions.
    \item Produto escalar entre quaternions.
    \item Extração do ângulo do quaternion.
    \item Extração do eixo do quaternion.
    \item Cálculo da norma.
    \item Normalização. Semelhante aos vetores, pode simplesmente normalizar ou retornar 
        uma cópia normalizada.
    \item Conversão para matriz.
    \item Interpolação linear e interpolação linear esférica entre quaternions.
\end{itemize}

\subsection{Outras Utilidades}

Além das funções mencionadas anteriormente, ainda existem algumas outras funções que 
servem como convenções para facilitar o processo de desenvolvimento e minimização de 
código escrito.

A biblioteca matemática também possui funções que não estão associadas com nenhuma 
estrutura, por exemplo, funções trigonométricas tais como: cotangente, conversão de 
graus para radianos e vice-versa.

Há constantes que também são utilizadas com frequência, como PI, epsilon, e um limitante 
arbitrário de pontos flutuantes. Esse limitante é utilizado para calcular a igualdade 
entre pontos flutuantes e consequentemente, todas as estruturas implementadas. Essa 
igualdade deve ser calculada de maneira diferente da igualdade entre inteiros, isso 
porque ao longo da execução, os pontos flutuantes acumulam "lixo", pequenos erros de 
cálculo em suas menores casas decimais, por esse motivo, dois números reais podem ser 
iguais, mas a operação de igualdade retorna falso por causa desses erros acumulados. A 
igualdade entre dois pontos flutuantes pode ser calculada da seguinte maneira: 

\begin{equation}
    \begin{aligned}
        d = |x - y| \\
        x = y \iff d < T \\
        x,\ y,\ d,\ T \in \mathbb{R}
    \end{aligned}
\end{equation}

\vspace{.5cm}

Onde $x$ e $y$ são os operandos, $d$ é a diferença entre eles e $T$ é o limitante de 
pontos flutuantes.

Por exemplo, considerando dois números de ponto flutuante: $x = 2.0$ e $y = 2.000001$, a 
determinação do limitante $T$ irá também determinar se esses dois números são iguais ou
não. Para um $T = 10^{-5}$, teria-se:

\begin{equation}
    \begin{aligned}
        d = |x - y| = 0.000001 = 10^{-6}\\
        x = y \iff 10^{-6} < 10^{-5} \\
        x,\ y,\ d,\ T \in \mathbb{R}
    \end{aligned}
\end{equation}

\vspace{.5cm}

Neste caso, para a escolha de $T = 10^{-5}$, os números $x$ e $y$ são iguais.

Construir matrizes manualmente é um processo demorado e propício a erros, por isso, a 
biblioteca matemática possui diversas funções que criam matrizes prontas que são 
frequentemente utilizadas. A seguir serão listadas matrizes que podem ser criadas a 
partir de funções específicas:
\begin{itemize}
    \item Matriz identidade $3 \times 3$ ou $4 \times 4$.
    \item Matriz nula $3 \times 3$ ou $4 \times 4$.
    \item Conversão de uma matriz $3 \times 3$ para uma $4 \times 4$ e vice-versa.
    \item Matriz de translação, criada a partir de um vetor 3D contendo o deslocamento em 
        cada um dos eixos.
    \item Matriz de rotação, criada a partir de um ângulo e do eixo de rotação. Existe 
        uma função com esses mesmos parâmetros para criar um quaternion ao invés de uma 
        matriz.
    \item Matriz de escala, criada a partir de um vetor 3D contendo o fator de escala 
        para cada um dos eixos.
    \item Matriz de visualização, criada a partir de um vetor indicando a posição, um 
        vetor indicando a direção e um vetor que representa o eixo que aponta para cima.
    \item Matriz de projeção perspectiva, criada a partir de um ângulo que representa o 
        campo de visão, a proporção da tela (largura por altura), a distância até o 
        plano perto e a distância até o plano longe.
\end{itemize}

\section{Componente Gráfico}

O componente gráfico de um motor de jogos é um dos principais módulos, devido a 
considerável quantidade de sub-tarefas que ele realiza, alguns exemplos são: definir 
as malhas de cada objeto, gerenciamento da câmera, gerenciamento das cenas, 
manipulação da parte configurável do \textit{pipeline} de renderização, configuração 
das otimizações de renderização, interfaceamento com a API gráfica através da 
utilização do renderizador gráfico de baixo-nível (seção~\ref{lowlevelrenderer}) e 
também de outras maneiras, como por exemplo a utilização de funções que compõem uma 
interface para a manipulação das variáveis contidas nos \textit{shaders}, definição da 
ordem de renderização dos objetos da cena, entre outros. 

A parte gráfica é a última a ser atualizada em um quadro, antes da renderização da 
cena. As atualizações dessa parte visual consistem em alterações nas propriedades dos 
objetos que estão na cena, como suas matrizes de transformação, cores, texturas, 
programa de \textit{shader} que irão utilizar, suas malhas e seus efeitos de 
pré-processamento ou pós-processamento. Além disso, há atualizações de outros 
parâmetros não relacionados aos objetos geométricos, como a matriz de visualização e 
projeção, parâmetros das fontes de iluminação, alteração da resolução da tela, entre 
outros.

Para o motor desenvolvido neste trabalho, há apenas a implementação do 
\textit{vertex shader} e do \textit{fragment shader}, pois estes são os únicos que são 
indispensáveis para a construção do \textit{pipeline} de renderização, o restante dos 
\textit{shaders} possuem implementações padrões já fornecidas pelo 
OpenGL~\cite{shreiner2013opengl}.

Da parte manipulável do \textit{pipeline} de renderização, o motor permite a 
alteração direta das posições dos objetos na cena, a hierarquia dos objetos, suas 
malhas e seus programas de \textit{shader}. Além disso, é também possível a alteração 
dos parâmetros das matrizes de visualização e projeção e também os parâmetros de 
iluminação através de variáveis uniforme.

As variáveis uniformes são utilizadas para qualquer parâmetro existente nos 
\textit{shaders} que se deseja modificar ao longo da execução da aplicação. Suas 
diferenças em relação às variáveis normais é que as variáveis uniformes são 
modificadas apenas no nível de aplicação, sendo usadas nos \textit{shaders} apenas 
para a leitura de seus valores. Outra diferença é que a declaração de uma variável 
uniforme é global no contexto do programa de \textit{shader}, e 
não somente no \textit{shader} que a variável uniforme foi 
declarada~\cite{wolff2013opengl}.

\subsection{Câmera}

A câmera estabelece o modo como a cena é visualizada pelo espectador. É basicamente 
constituída de dois componentes, a matriz de visualização, que irá determinar de qual 
posição a cena será vista e a partir dessa posição, de qual ângulo a cena será vista. 
Há também a matriz de projeção, que irá aplicar uma das técnicas de projeção sobre a 
cena e irá também remover da renderização os objetos que estão fora do campo de visão 
da câmera. 

Uma câmera pode ser configurada de maneiras diferentes, e os parâmetros dependerão de 
como é pretendida a interação do espectador com a cena. Alguns exemplos de 
comportamento incluem:
\begin{itemize}
    \item Câmera livre: possui livre movimentação ao longo dos três eixos
    \item Câmera 2.5D: possui livre movimentação ao longo de dois eixos, e o terceiro 
        é fixado, geralmente é o eixo que aponta para cima.
    \item Câmera esférica: a câmera se move em torno de uma esfera que geralmente 
        engloba a cena inteira, porém o tamanho desta esfera pode ser alterado, 
        causando os efeitos de \textit{zoom in} e \textit{zoom out}.
\end{itemize}

Pode existir mais de uma câmera na mesma cena e suas visões podem aparecer 
simultaneamente na tela, geralmente é feito um esquema de divisão de tela para que isso 
seja possível.

Por ser uma classe consideravelmente simples, não há diferença na classe de câmera 
entre as versões do motor. Conforme visto na figura~\ref{dodengine}, uma câmera 
armazena dois inteiros positivos, um para armazenar o índice do bloco de variáveis 
uniformes, e outro para 

\subsection{Grafo de Cena}

Consiste em uma estrutura para definir a hierarquia dos objetos de uma cena e as 
propriedades de cada um. Essa estrutura é um grafo acíclico direcionado cujos nós 
formam uma hierarquia. Cada 
nó possui um conjunto de propriedades, tais propriedades podem ser herdadas de seu 
nó pai e podem ser passadas para os nós filhos. Por exemplo, se um nó possui uma 
matriz de transformação, então nas coordenadas do mundo seus filhos não terão mais o 
centro do mundo como referência, mas sim o centro representado pela matriz de 
transformação do seu pai, e suas posições finais serão dadas pela combinação da suas 
matrizes de transformação com a do seu pai.

O esquema dos nós no grafo de cena permite fácil reutilização de componentes, se dois 
objetos idênticos forem necessários na cena, basta criar um nó com as propriedades e 
utilizar instanciação, e também permite flexibilidade, cada nó pode ter sua própria 
malha, programa de \textit{shader}, entre outros atributos~\cite{hughes2014computer}. 
As ligações permitem uma fácil construção de hierarquia, e também torna trivial coisas 
como uma mudança de posição de um subgrupo inteiro de objetos.

A figura~\ref{scenegraphexample} demonstra um exemplo de um grafo de cena que está 
representando parcialmente um carro utilizando hierarquia, nele há um nó que 
representa uma roda, este nó possui quatro instâncias e estas compartilham uma mesma 
malha que descreve a geometria da roda. Os nós da roda são filhos do nó que representa 
o carro como um todo.

\begin{figure}[h]
    \centering
    \captionof{figure}{Exemplo de um grafo de cena descrevendo parcialmente um objeto 
    que representa um carro.}
    \includegraphics[width =.6\textwidth]{../figuras/scenegraph}
    \par\medskip
    Disponível em: <http://www.opensg.org/htdocs/doc-1.8/PageScenegraph.html>. Acesso 
    em: 05/06/2017.
    \label{scenegraphexample}
\end{figure}

\subsection{Otimizações de Renderização}

Como o processo de renderização é computacionalmente caro, é necessário que esse 
processo seja o mais otimizado o possível. Até mesmo simples otimizações podem causar 
um impacto considerável no desempenho da renderização. 

Dentre outras, há duas otimizações de renderização que são utilizadas neste trabalho: 
\textit{backface culling} e \textit{frustum culling}.

O \textit{backface culling} é uma técnica que elimina um dos dois lados de uma face. 
Como em aplicações 3D os objetos consistem em malhas que por sua vez são um conjunto 
de faces adjacentes, apenas um dos lados dessas faces são vistos, chamado de parte de 
fora das malhas. O interior dos objetos, chamado de parte de dentro, não é visto pelo 
espectador, por isso não há motivo em renderizá-lo, o \textit{backface culling} é 
encarregado de eliminar essa parte do interior~\cite{hughes2014computer}.

O \textit{frustum culling} é a remoção total ou parcial dos objetos que estão fora do 
\textit{frustum} de visualização da câmera. Uma cena pode ser potencialmente extensa e 
conter objetos com formas complexas, por isso é importante que os parâmetros que 
definem as dimensões do \textit{frustum} de visualização sejam adequadamente ajustados, 
para que objetos muito distantes ou fora do ângulo de visualização da câmera não sejam 
renderizados.

\section{Gerenciador de Recursos}

O gerenciador de recursos consiste em uma interface unificada que serve como conexão 
entre o conteúdo técnico da aplicação, nesse caso o motor de jogos e todos os seus 
módulos, e o conteúdo criativo, conhecido como \textit{assets}, o qual é constituído 
de malhas, animações, sons, música, planos de fundo, fontes, texturas, e qualquer outro 
tipo de conteúdo que seja julgado necessário. Além dos \textit{assets}, há também 
outros tipos de dados que são gerenciados por este componente, que são \textit{inputs} 
do motor de jogos, como scripts, cenas e \textit{shaders}.

A função dessa interface é garantir acesso a esses \textit{assets} e \textit{inputs} 
do motor de jogos a partir da utilização do sistema de arquivos do sistema operacional 
no qual a aplicação está sendo executada, onde esse conteúdo externo está armazenado. 
O acesso ao sistema de arquivos já é fornecido por bibliotecas da linguagem de 
programação. Cabe então ao gerador de recursos fornecer funções com um maior nível de 
abstração que utiliza essas chamadas ao sistema de arquivos disponibilizadas pela 
linguagem, esse processo é conhecido como criação de um \textit{wrapper}. 

Algumas das funcionalidades presentes na API de acesso ao sistema de arquivos 
incluem~\cite{gregory2009game}:
\begin{itemize}
    \item Manipulação de nomes de arquivos e caminhos de diretórios,
    \item Abrir, fechar, ler e escrever arquivos individuais,
    \item Listar os conteúdos de um diretório,
    \item Gerenciamento de pedidos de I/O assíncronos
\end{itemize}

Além dessas funções, é também da responsabilidade do gerenciador de recursos garantir 
que apenas uma cópia de cada arquivo carregado no sistema exista, economizando o uso 
da memória, a qual é escassa. Por exemplo, vários objetos presentes em uma cena podem 
compartilhar uma mesma malha, então mesmo que exista mais de um objeto que utilize a 
mesma malha, somente uma cópia desta é necessária estar carregada no sistema.

Para o trabalho proposto, o gerenciador de recursos possui três funcionalidades 
principais:
\begin{itemize}
    \item Carregar malhas externas,
    \item Carregar \textit{shaders},
    \item Garantir a singularidade de cada um dos recursos carregados no sistema.
\end{itemize}

Para carregar malhas externas, o gerenciador de recursos possui um \textit{parser} 
de arquivos no formato OBJ, um formato de arquivo para definição de geometria. Um 
arquivo OBJ contém as posições de cada vértice, as coordenadas de textura, as normais 
de cada vértice e a lista de faces que compõem o objeto. As faces são triangulares, e 
cada face é constituída de três triplas de índices, o primeiro índice é de um dos 
vértices do triângulo, o segundo índice é da coordenada de textura do vértice e o 
terceiro índice é a normal do vértice.

Para carregar os \textit{shaders}, além de especificar o caminho do diretório onde o 
vértice se encontra, há um outro parâmetro que especifica qual é o tipo do 
\textit{shader} que está sendo carregado, isso é necessário para que a sua compilação 
seja adequada.

\section{Considerações Finais do Capítulo}

Foi apresentada a proposta deste trabalho, um motor de jogos com modelagem orientada a 
dados, algumas das estratégias escolhidas para a sua implementação e o que é 
necessário para modelar alguns dos componentes presentes no motor.

Como um motor de jogos é apenas um recurso utilizado para a criação de uma aplicação 
gráfica, foi necessário propor uma estratégia para a verificação da modelagem orientada 
a dados como uma forma de otimização de desempenho, e também para a comparação com as 
abordagens mais tradicionais de se implementar um jogo.

Todas as operações matemáticas apresentadas e explicadas na seção~\ref{secmathconcepts} 
são utilizadas em uma biblioteca matemática, essa por sua vez é extensivamente 
utilizada nos outros módulos do motor. As funcionalidades de cada uma das estruturas 
utilizadas foram listadas. Além disso, algumas funcionalidades e convenções 
relacionadas com nenhuma das estruturas também foram listadas.

O componente gráfico é uma parte extensa do motor de jogos e que precisa lidar com 
vários fatores diferentes. Esses fatores foram apresentados e juntamente com eles 
quais foram as decisões tomadas para a implementação ou gerenciamento de cada um.

Foi apresentado o conceito de uma câmera, e possíveis configurações diferentes que 
esta pode ter. Também foi apresentada uma estrutura para lidar com a hierarquia de 
objetos de uma cena e suas propriedades, o grafo de cena, e duas técnicas de otimização 
de renderização utilizadas neste trabalho.
Por fim, um outro componente foi apresentado, o gerenciador de recurso, que fornece uma 
interface para acessar todo o conteúdo criativo, que é externo ao motor de jogos, e
também os \textit{inputs} para o motor.
