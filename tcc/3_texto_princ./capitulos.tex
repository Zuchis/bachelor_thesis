\setlength\abovedisplayskip{0pt} \setlength\belowdisplayskip{0pt}
\setlength\abovedisplayshortskip{0pt} \setlength\belowdisplayshortskip{0pt}

\chapter{Fundamenta\c{c}\~ao Te\'orica}
\label{cap2}

Neste capítulo serão discutidos e explicados todos os conceitos e 
fundamentação teórica necessários para a compreensão da proposta 
feita nesse trabalho, assim como a abordagem que será utilizada 
para a implementação de todos os componentes que juntos vão compor 
o motor de jogos que será o objeto de estudo deste trabalho.

\section{Comunicação Entre o Processador e a Memória}

\subsection{Gargalo do Processador-Memória}

\section{Motor de Jogos}
\label{secgameengine}

O termo e o conceito de motor de jogos surgiram no início da década de 1990, quando a 
empresa \textit{Id Software} lançou o jogo \textit{DOOM} e, juntamente com ele, seu 
motor de jogos conhecido como \textit{DOOM Engine}, que depois foi nomeado como 
\textit{Id Tech 1}~\cite{gregory2009game}.

O jogo \textit{DOOM}, através da \textit{Id Tech 1}, é considerado o primeiro jogo da 
indústria de jogos digitais que possui uma clara separação entre os componentes núcleo 
do jogo, chamada de parte lógica, dos componentes criativos, tais como animações, 
modelos geométricos, sons, imagens, planos de fundo, música, etc.

A \textit{Id Software}, além de ter criado um novo conceito de \textit{software} 
na indústria de jogos que atualmente é considerado padrão em grandes empresas e ter 
gerado uma vasta família de motores de jogos que partiram da \textit{Id Tech 1}, também 
conceberam um novo paradigma para se desenvolver jogos digitais, onde a produção de todo 
o conteúdo lógico é independentemente e separadamente feita dos componentes criativos.

A maior vantagem da utilização de motores de jogos consiste na reutilização de código. 
Isso significa que, para rotinas parecidas, ou até mesmo para outros projetos, um mesmo 
código pode ser utilizado mudando-se apenas alguns parâmetros. Além disso, motores de 
jogos mais completos geralmente permitem uma rápida prototipagem de novos projetos,
requer uma habilidade menor por parte dos programadores e minimiza seus esforços 
através de abstrações.

A implementação de um motor de jogos é feito através do desenvolvimento separado de 
diversos componentes. Cada componente é responsável por uma parte específica da parte 
lógica do jogo, ao oposto do que era feito na programação de jogos tradicional, cujo 
objetivo primário era maximizar o desempenho para o hardware utilizado. Essa preocupação 
com o desempenho, juntamente com o curto intervalo de tempo que os desenvolvedores tinham 
para terminar os projetos geralmente resultava em códigos que não ficavam conforme os 
preceitos de boa engenharia de software segundo Kruchten~\cite{Kruchten2006}.

Dada a complexidade que é desenvolver um motor de jogos, considerando todos os aspectos que 
esta deve abranger, desenvolver um código monolítico sem estrutura arquitetural e sem se 
preocupar com o design geral do sistema, implica em um \textit{software} cujos componentes 
são todos dependentes entre si. O resultado dessa dependência é um sistema frágil, no qual 
pequenas mudanças em alguma parte do código pode afetar outras partes de maneiras não 
óbvias, além de desencorajar os programadores de alterar o código ou refatorá-lo para 
aumentar sua qualidade~\cite{Keenan2011}.

Por esse motivo, é importante que um motor de jogos esteja devidamente modularizado para 
evitar um sistema frágil, e facilitar a adição de novos componentes. É importante lembrar 
que, apesar de ser desejável que os componentes estejam o mais independentes o possível 
entre si, estes devem estar funcionando perfeitamente em sinergia, isto é, um motor de 
jogos não funciona com vários componentes executando separadamente, mas sim com a 
comunicação entre eles de maneira clara e eficiente.

A comunicação e integração entre os diferentes componentes de um motor de jogos faz parte 
da modelagem da arquitetura deste. Conforme apontado por Anderson et 
al.~\cite{Anderson2008}, um problema que ainda persiste atualmente é a falta de material 
na literatura a respeito da modelagem da arquitetura de motores de jogos, sendo que a 
maior parte da pesquisa disponível foca somente nos componentes separados, como 
renderização, inteligência artificial (IA) ou rede. Ainda é salientado pelo autor que 
ainda não há um consenso sobre os limites que separam um jogo do seu motor, portanto 
há espaço a ser explorado nessa área.

A quantidade de componentes presentes em um motor de jogos é altamente dependente da 
complexidade desejada para o jogo sendo desenvolvido, alguns dos componentes mais 
presentes são: componente gráfico, colisões, física, inteligência artificial, rede, som 
e animação.

\section{Conceitos Matemáticos}
\label{secmathconcepts}

Qualquer motor de jogos necessita de uma biblioteca matemática, uma vez que 
jogos são aplicações as quais são extremamente dependentes de operações e 
conceitos matemáticos. 

Essas bibliotecas fornecem diversas utilidades, algoritmos e funções 
matemáticas, tais como: estruturas de dados personalizadas de vetores, 
matrizes e quaternions; operações matriciais e vetoriais; rotações e 
interpolações de quaternions; trigonometria; operações geométricas com 
linhas, raios, esferas, etc., manipulação de \textit{splines}, integração 
numérica, e quaisquer outras utilidades que os desenvolvedores 
necessitarem~\cite{gregory2009game}.

A área da computação gráfica está intimamente ligada às áreas da matemática de 
álgebra linear e geometria analítica, a maior parte dos conceitos matemáticos empregados 
neste trabalho pertencem a uma destas áreas. Visto que ambas estas áreas são vastas e vão 
muito além do escopo deste trabalho, o restante desta seção tratará dos conceitos e 
propriedades que são relevantes para a computação gráfica apenas.

Verth e Bishop~\cite{Verth:2008} e Mortenson~\cite{mortenson1999mathematics} fizeram uma 
excelente cobertura de toda a matemática essencial utilizada em motores de jogos. O restante 
da seção cobrirá apenas os tópicos mais essenciais e para uma abordagem mais completa do 
assunto, esses trabalhos deverão ser consultados. Todos os conceitos apresentados aqui 
são utilizados para a elaboração da biblioteca matemática presente neste trabalho.

\subsection{Vetores e Pontos}

Vetores e pontos são as estruturas essenciais de todos os objetos presentes em 
aplicações gráficas. 

Os pontos representam posições do espaço, podem ser utilizados para determinar os 
vértices da superfície de um objeto, que consequentemente determinará seu formato 
(chamado de modelo), e também podem representar a posição de um objeto no espaço, 
essa posição geralmente se refere ao centro do objeto. Se os pontos de um objeto 
forem alterados, o modelo desse objeto também será alterado.

Vetores (no campo da geometria) são entidades que possuem uma direção e um comprimento, 
chamado de magnitude e representam a diferença entre dois pontos. São utilizados para 
armazenar grandezas (como velocidade, gravidade, aceleração, atrito, etc.) e direções.

Há alguns casos específicos de vetores que recebem nomeações 
diferentes, por exemplo vetores cuja magnitude é igual a 1 são chamados de vetores 
unitários ou vetores normalizados. Um vetor cuja magnitude é igual a 0 é chamado de 
vetor zero, e não possui nenhuma direção. 

Para representar um vetor no computador, utiliza-se a chamada "base Euclidiana padrão", 
composta pelos três vetores unitários linearmente independentes $i$, $j$ e $k$ que são 
perpendiculares entre si para o caso do espaço tridimensional $\mathbb{R}^3$, para o 
espaço bidimensional $\mathbb{R}^2$, utiliza-se somente os vetores $i$ e $j$. 

Utilizando essa base, pode-se representar unicamente qualquer vetor no espaço através 
de uma combinação linear dos três vetores base da seguinte maneira: 

\begin{equation}
    \centering
    v = xi + yj + zk
\end{equation}

Os coeficientes $x$, $y$ e $z$ representam o deslocamento em cada um dos eixos. A 
figura~\ref{3dbasisvector} demonstra como um vetor é representado utilizando a base 
Euclidiana padrão. Esses coeficientes são utilizados para representar um vetor 
algebricamente através de uma tripla $(x,y,z)$, ou uma dupla para o caso dos vetores 
2D, e são conhecidos como componentes do vetor.

\begin{figure}[h]
    \centering
    \includegraphics[width =.6\textwidth]{../figuras/3dbasisvector}
    \caption{Representação de um Vetor na Base Tridimensional.}
    Fonte: \cite{Verth:2008}.
    \label{3dbasisvector}
\end{figure}

Com essa representação algébrica, pode-se definir as operações sobre vetores tão 
utilizadas na computação gráfica 

\subsection{Operações Sobre Vetores}

Nesta seção serão apresentadas operações que podem ser feitas sobre vetores e entre 
vetores. Para todas as operações serão utilizados como exemplo vetores no espaço 3D.
\subsubsection{Adição}

A adição entre dois vetores é feita através da soma de cada um dos componentes de um 
vetor com os componentes correspondentes do outro vetor.

\begin{equation}
    \begin{aligned}
        v1 + v2 = (x_1, y_1, z_1) + (x_2, y_2, z_2) \\
        v1 + v2 = (x_1 + x_2, y_1 + y_2 , z_1 + z_2)
    \end{aligned}
\end{equation}

\subsubsection{Subtração}

A subtração entre dois vetores é semelhante à adição, porém são feitas operações de 
substrações entre os componentes dos operandos.

\begin{equation}
    \begin{aligned}
        v1 - v2 = (x_1, y_1, z_1) - (x_2, y_2, z_2) \\
        v1 - v2 = (x_1 - x_2, y_1 - y_2, z_1 - z_2)
    \end{aligned}
\end{equation}

Observa-se que assim como a subtração entre escalares, a subtração entre vetores também 
não é comutativa.

\subsubsection{Multiplicação por Escalar}

Dado um certo coeficiente $k$, a multiplicação de um vetor $v$ pelo escalar $k$ é dada 
pela multiplicação do escalar por cada um dos componentes do vetor:

\begin{equation}
    \begin{aligned}
        kv = k(x, y, z)\\
        kv = (kx, ky, kz)
    \end{aligned}
\end{equation}

\subsubsection{Igualdade Entre Vetores}

Um vetor $v1$ é igual a um vetor $v2$, se todos os componentes de $v1$ forem iguais aos 
componentes correspondentes de $v2$. 

\begin{equation}
    \begin{aligned}
        v1 = v2\\
        (x_1, y_1, z_1) = (x_2, y_2, z_2)\\
        x_1 = x_2, y_1 = y_2, z_1 = z_2
    \end{aligned}
\end{equation}

\subsubsection{Magnitude}

O operador de magnitude serve para calcular o comprimento de um vetor. Para o fazê-lo, 
a norma utilizada é a norma Euclidiana, cujo cálculo consiste na raiz quadrada da soma  
dos quadrados dos componentes. O operador de norma é denotado por: $||v||$. Dado um 
vetor $v$, o tamanho do vetor $d$ é dado por:

\begin{equation}
    \begin{aligned}
        ||v|| = d = \sqrt{x^2 + y^2 + z^2}
    \end{aligned}
\end{equation}

\subsubsection{Normalização}

A normalização de um vetor cria um vetor unitário $v'$ a partir de um vetor $v$, 
mudando sua magnitude para 1, porém mantendo sua direção. Isso é feito a partir da
divisão de um vetor pela sua norma:

\begin{equation}
    \begin{aligned}
        v' = \frac{v}{||v||}
    \end{aligned}
\end{equation}

\subsubsection{Produto Escalar}

O produto escalar entre dois vetores, como o nome sugere, resulta em um escalar a partir 
dos operandos, a operação é feita multiplicando-se os dois vetores 
componente-a-componente e depois somando os resultados:

\begin{equation}
    \begin{aligned}
        v1 \cdotp v2 = v1_xv2_x + v1_yv2_y + v1_zv2_z
    \end{aligned}
\end{equation}

Se os vetores $v1$ e $v2$ formarem um ângulo de 90 graus entre si, então o produto 
escalar entre eles será zero. Então pode-se dizer que dois vetores serão 
perpendiculares, ou ortogonais, quando $v1 \cdotp v2 = 0$.

Além de verificar a ortogonalidade entre dois vetores, o produto escalar pode fornecer 
outras informações, por exemplo, se $v1 \cdotp v2 > 0$, então o ângulo entre eles é 
menor do que 90 graus, se $v1 \cdotp v2 < 0$, então o ângulo entre eles é maior do que 
90 graus, esse teste não requer que os vetores estejam normalizados.

\subsubsection{Produto Vetorial}

O produto vetorial, opostamente ao produto escalar, tem como resultado da operação um 
vetor. O vetor resultante $w$ do produto vetorial entre $v1$ e $v2$ será sempre 
ortogonal a estes. Como essa operação não é comutativa, a direção do vetor resultante 
dependerá da ordem dos operandos, ou seja, há duas saídas possíveis dessa operação, uma 
é a negação da outra. O produto vetorial é determinado pela fórmula:

\begin{equation}
    \begin{aligned}
        v1 \times v2 = (v1_yv2_z - v2_yv1_z, v1_zv2_x - v2_zv1_x, v1_xv2_y - v2_xv1_y)
    \end{aligned}
\end{equation}

A figura~\ref{piccrossproduct} demonstra geometricamente um produto vetorial. Os usos mais 
comuns para o produto vetorial é para gerar um vetor ortogonal a outros dois e para 
verificar se dois vetores são paralelos entre si.

Diferentemente do produto escalar, o produto vetorial não é definido para vetores 2D.

\begin{figure}[h]
    \centering
    \includegraphics[width =.4\textwidth]{../figuras/crossproduct}
    \caption{Produto vetorial com os dois possíveis resultados representados.}
    Disponível em: <https://en.wikipedia.org/wiki/Cross\_product>. Acesso em: 27/05/2017.
    \label{piccrossproduct}
\end{figure}

\subsection{Matrizes}
\label{matrices}

Matrizes são \textit{arrays} bidimensionais nas quais cada valor individual é chamado de 
elemento. A descrição de uma matriz é feita especificando o seu número de linhas e número 
de colunas, sendo $m$ o número de linhas e $n$ o número de colunas, é dito que é uma matriz 
$m$ por $n$, denotado por $m\ x\ n$. A relação da quantidade de linhas e colunas é também 
conhecida como o tamanho da matriz.

Uma linha é uma sequência de elementos na horizontal da esquerda para a direita, enquanto 
que uma coluna é uma sequência de elementos na vertical de cima para baixo. Para 
referenciar um elemento específico de uma matriz $A$, usa-se a notação: $a_{i,j}$, onde 
$i$ referencia uma linha e $j$ uma coluna. Dessa maneira, o elemento $a_{1,2}$ é o elemento 
que está na primeira linha e na segunda coluna na matriz A.

O conjunto de elementos os quais o número da linha é igual ao número da coluna (ex: 
$a_{1,1}$) é chamado de diagonal principal.

Alguns casos específicos de matrizes recebem denotações especiais. A seguir serão 
listadas algumas dessas matrizes específicas:
\begin{itemize}
    \item Matriz quadrada: matriz cujo número de linhas é igual ao número de colunas 
    \item Matriz zero ou nula: matriz na qual todos os elementos são iguais a zero
    \item Matriz diagonal: matriz cujos únicos elementos que não são zero são os da 
        diagonal principal
    \item Matriz Identidade: matriz na qual todos os elementos da diagonal principal são 
        iguais a um, e o restante igual a zero. A matriz identidade é denotada por $I$.
    \item Matriz coluna: matriz que só possui uma coluna de elementos
    \item Matriz linha: matriz que só possui uma linha de elementos
\end{itemize}

Existem outros casos específicos de matrizes, como matrizes triangulares,  mas não são tão 
importantes quanto estas. Uma característica importante das matrizes linha e coluna é 
que elas podem ser utilizadas para representar vetores matricialmente.

\subsection{Operações Sobre Matrizes}

Nesta seção serão apresentadas operações feitas sobre matrizes, entre matrizes e também 
entre matrizes e vetores.

\subsubsection{Igualdade entre Matrizes}

Duas matrizes são iguais se elas possuem a mesma dimensão e todos os seus elementos 
correspondentes são iguais. Ou seja, para duas matrizes de dimensão $m \times n$:

\begin{equation}
    \begin{aligned}
        A = B\\
        a_{i,j} = b_{i,j}\\
        \forall i \in {1..m} \land \forall j \in {1..n}
    \end{aligned}
\end{equation}

\subsubsection{Adição e Subtração}

Dadas duas matrizes $A$ e $B$, a soma entre elas é feita de maneira semelhante à soma de 
vetores, soma-se componente-a-componente. Sendo $S$ a soma de $A$ e $B$, teremos:

\begin{equation}
    \begin{aligned}
        S = A + B\\
        s_{i,j} = a_{i,j} + b_{i,j}
    \end{aligned}
\end{equation}

A subtração é feita de maneira semelhante, subtraindo-se os componentes ao invés de 
somá-los. Assim como números reais e vetores, a subtração não é comutativa para matrizes.

Nota-se que para realizar essas operações, os tamanhos de $A$, $B$ e $S$ devem ser 
iguais. 

\subsubsection{Multiplicação por Escalar}

De maneira similar à multiplicação de um vetor por um escalar, dado um escalar $k$, 
cada elemento da matriz é multiplicado por $k$. Sendo $P$, a multiplicação da matrix $A$ 
pelo escalar $k$, esta é dada por:

\begin{equation}
    \begin{aligned}
        P = kA\\
        p_{i,j} = k \dot a_{i,j}
    \end{aligned}
\end{equation}

\subsubsection{Matriz Transposta}

A transposta de uma matriz $A$, denotada por $A^T$, troca as linhas pelas colunas de $A$ 
e vice-versa. Isso é feito trocando os elementos ao longo da diagonal principal, de 
tal forma que: $(A^T)_{i.j} = (A)_{j,i}$

\subsubsection{Blocos de Matrizes}

Uma convenção para a representação de matrizes é representá-las como blocos de 
submatrizes, ao invés de representá-las com todos os elementos, por exemplo: \\

$
    \begin{bmatrix}
        1 & 2 & 0 \\
    -4 & 5 & 0 \\
        0 & 0 & 1 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
        A & 0 \\
        0^T & 1 \\
    \end{bmatrix}
$

\vspace{1cm}

Onde $0^T$ é uma linha de zeros e A:\\ 

$A =  \begin{bmatrix}
        1 & 2 \\
       -4 & 5 \\
      \end{bmatrix}$

\subsubsection{Multiplicação Entre Matrizes}

Essa é a operação de matrizes mais utilizada em aplicações gráficas, também conhecida 
como produto de matrizes. Com essa operação é possível fazer duas coisas extensivamente 
usadas: a primeira é a transformação de um vetor multiplicando-o por uma matriz. A 
segunda é multiplicar duas matrizes juntas para formar uma única matriz que realiza as 
transformações combinadas daquelas.

O produto $C$ das matrizes $A$ e $B$ é denotado da mesma maneira que números reais: 
$C = AB$. Para calcular os elementos do produto $c_{i,j}$, realiza-se um produto 
escalar da linha $i$ de $A$ com a coluna $j$ de B, isso pode ser representado da 
seguinte maneira:

\begin{equation}
    \begin{aligned}
        c_{i,j} = \displaystyle\sum_{k=0}^{n-1} a_{i,k}b{k,j}
    \end{aligned}
\end{equation}

Para se realizar o produto escalar entre as linhas e as colunas, elas devem possuir a 
mesma dimensão, ou seja, a multiplicação entre duas matrizes somente é possível se o 
número de colunas de uma for igual ao número de linhas da outra. Isso também implica 
que apenas matrizes quadradas podem ser multiplicadas por si mesmas. 

Conforme mencionado na seção~\ref{matrices}, vetores podem ser representados 
matricialmente através de uma matriz linha ou matriz coluna, essas representações são 
utilizadas para realizar transformações sobre vetores, através de uma multiplicação 
entre matriz e vetor, para o caso de um vetor representado por uma matriz coluna, a 
multiplicação de um vetor $v$ por uma matriz $A$ é dada por: 

\begin{equation}
    \begin{bmatrix}
        a_{1,1} & a_{1,2} & a_{1,3}\\
        a_{2,1} & a_{2,2} & a_{2,3}\\
        a_{3,1} & a_{3,2} & a_{3,3}\\
    \end{bmatrix}
    \begin{bmatrix}
        v_x \\
        v_y \\
        v_z \\
    \end{bmatrix}
\end{equation}

Para que a multiplicação possa ser realizada nesse caso, o número de colunas da matriz 
deve corresponder ao número de elementos do vetor, o resultado dessa multiplicação 
será:

$
Av = (v \cdotp a_{1}^{T}, v \cdotp a_{2}^{T}, v \cdotp a_{3}^{T})
$

Onde $a_{1}^{T}$, $a_{2}^{T}$ e $a_{3}^{T}$ são as linhas 1, 2 e 3 da matriz $A$, 
respectivamente. 

Caso uma matriz linha seja utilizada para representar o vetor, o número de linhas da 
matriz deve corresponder ao número de elementos do vetor, e o vetor deverá ser colocado 
à esquerda da operação.

É importante salientar que a multiplicação entre matrizes não é comutativa, apesar de 
ainda ser associativa como vetores e números reais.

A matriz identidade (seção~\ref{matrices}), é o elemento neutro da multiplicação de 
matrizes, isto é, para qualquer matriz $A$, a multiplicação pela matriz identidade $I$ 
resultará em $A$:

\begin{equation}
    \begin{aligned}
        A \cdotp I = I \cdotp A = A
    \end{aligned}
\end{equation}

\subsubsection{Matriz Inversa}

A inversa de uma matriz $A$, definida como $A^-1$, é uma matriz a qual multiplicada por 
$A$ resulta na matriz identidade $I$:

\begin{equation}
    \begin{aligned}
        A \cdotp A^-1 = I
    \end{aligned}
\end{equation}

E: 

\begin{equation}
    \begin{aligned}
        A^-1 \cdotp A = I
    \end{aligned}
\end{equation}

Para que essa multiplicação possa ocorrer, o número de colunas da matriz inversa 
precisa ser igual ao número de linhas da original, e a recíproca também deve ser 
verdadeira. Por isso, uma matriz e sua inversa devem ser quadradas e de mesma dimensão, 
portanto nem todas as matrizes possuem uma inversa, já nem todas as matrizes são 
quadradas. A inversa da inversa retorna a matriz original. 

Uma das utilidades da matriz inversa é que ela pode reverter a transformação feita 
pela sua matriz original, multiplicando o vetor transformado pela inversa da matriz 
que realizou a transformação.

Existem várias maneiras de se computar a matriz inversa, o método utilizado neste 
trabalho é o método de Cramer~\cite{cramer1750introduction}.

\subsubsection{Determinante}

O determinante é uma quantidade escalar criada a partir da avaliação dos elementos de 
uma matriz quadrada. Para o caso de uma matriz $2 \times 2$, se utilizarmos as colunas 
dela como os lados de um paralelogramo, então o valor absoluto do determinante é igual 
a área do paralelogramo. Já uma matrix $3 \times 3$, o valor absoluto do determinate 
é igual ao volume de um paralelepípedo. 

O determinante pode ser representado de duas maneiras, por det$(A)$ ou $|A|$. A segunda 
é mais comum ao se mostrar os elementos da matriz. 

O cálculo do determinante é dependente da dimensão da matriz. No escopo de aplicações 
gráficas, apenas o cálculo dos determinantes de matrizes $2 \times 2$ e $3 \times 3$ 
são necessários.

O determinante de uma matriz $2 \times 2$ é dado por:

\begin{equation}
    \begin{aligned}
        \begin{vmatrix}
            a & b \\
            c & d
        \end{vmatrix}
        = 
        ad - bc
    \end{aligned}
\end{equation}

E o determinante de uma matriz $3 \times 3$ é dado por:

\begin{equation}
    \begin{aligned}
        \begin{vmatrix}
            a & b & c\\
            d & e & f\\
            g & h & i\\
        \end{vmatrix}
        = 
        a(ei - fh) -b(di - fg) + c(dh - eg)
    \end{aligned}
\end{equation}

\subsection{Transformações Afins}

As transformações afins mapeiam pontos e vetores de um espaço afim para outro, e elas 
podem ser aplicadas utilizando-se operações matriciais.

De uma maneira simples, uma transformação afim pode ser representada por uma 
multiplicação de matriz seguida por uma adição de vetor:

\begin{equation}
    \begin{aligned}
        Ax + y
    \end{aligned}
\end{equation}

Onde $A$ é uma matrix $m \times n$, $y$ é um vetor de tamanho $m$, e $x$ consiste nas 
coordenadas $(x_0,\ldots,x_{n-1})$. Essa transformação pode ser representada utilizando 
blocos de matrizes: 

\begin{equation}
    \begin{bmatrix}
        A & y\\
        0^T & 1\\
    \end{bmatrix}
    \begin{bmatrix}
        x \\
        1 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
        Ax + y\\
        1\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Para que essa multiplicação possa ocorrer, é preciso representar $x$ com um componente 
adicional cujo valor é $1$. Computacionalmente essa abordagem não é atrativa, pois 
armazenar um vetor de zeros $0^T$, o $1$ no canto inferior direito e a dimensão extra 
de $x$ consomem memória desnecessariamente. Por isso, geralmente utiliza-se uma 
representação para transformações afins na qual esses termos são implícitos, como 
por exemplo uma matriz de $m \times (n + 1)$ dimensões. Portanto, ao se trabalhar com 
transformações no espaço $\mathbb{R}^3$, uma transformação afim será representada por 
uma matriz $4 \times 4$. De maneira análoga, uma transformação afim no espaço 
$\mathbb{R}^2$ será representada por uma matriz $3 \times 3$.

Em aplicações gráficas, essas transformações são utilizadas para a manipulação dos 
objetos em um espaço virtual, também chamado de cena. As transformações afins mais 
utilizadas são para alterar a posição, a orientação e o tamanho de um objeto, essas 
transformações são a translação, a rotação e a escala, respectivamente.

\subsubsection{Translação}

A translação move um ponto, ou um conjunto de pontos para o caso de um objeto, 
através do espaço. Já que todos os pontos de um objeto são transladados, a sua forma e 
tamanho não são alterados.

Para o caso de uma translação de um ponto no $\mathbb{R}^3$ com um deslocamento 
representado por um ponto $t$, a matriz de translação será definida por uma matriz 
$4 \times 4$ da seguinte forma:

\begin{equation}
    \begin{bmatrix}
        1 & 0 & 0 & t_x\\
        0 & 1 & 0 & t_y\\
        0 & 0 & 1 & t_z\\
        0 & 0 & 0 & 1\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Onde $t_x$, $t_y$ e $t_z$ representam os deslocamentos nos eixos $x$, $y$ e $z$ 
respectivamente.

\subsubsection{Rotação}

A rotação altera a orientação de um vetor em torno de algum eixo. Para um 
certo ponto, sua rotação é feita movendo-o ao longo de um arco planar uma distância 
constante de um outro ponto, chamado de centro da rotação. Existem dois tipo de 
rotações, as rotações puras que são feitas em torno dos três eixos que constituem a 
base Euclidiana padrão ($i$, $j$ e $k$), e as rotações que são feitas em torno de um 
eixo arbitrário qualquer. 

As rotações puras, apesar de serem mais simples, não são muito úteis, pois são 
limitadas, principalmente se se quer realizar uma rotação em torno de um eixo que é 
a combinação de outros, ou passar o eixo de rotação como argumento. Por esses motivos, 
as rotações puras não serão utilizadas nesse trabalho, ao invés disso, uma técnica de 
rotação mais eficiente será utilizada, que é a fórmula de rotação de Rodrigues, que 
permite rotacionar um vetor em torno de qualquer eixo arbitrário.

A fórmula de rotação de Rodrigues é definida por: 

\begin{equation}
    \begin{aligned}
        R = I + (\sin \theta)K + (1 - \cos \theta)K^2
    \end{aligned}
\end{equation}

\vspace{.5cm}

Onde $I$ é a matriz identidade, $\theta$ é o quanto quer-se rotacionar e $K$ é uma 
matriz dada por:

\begin{equation}
    \begin{bmatrix}
        0 & -k_z & k_y\\
        k_z & 0 & -k_x\\
        -k_y & k_x & 0\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Na qual $k_x$, $k_y$ e $k_z$ são os componentes do eixo em torno do qual se deseja 
rotacionar.

\subsubsection{Escala}

A escala modifica o tamanho de um vetor multiplicando cada um de seus componentes por 
um fator escolhido. As diferenças da transformação de escala da multiplicação por 
escalar dos vetores é que na escala, o coeficiente é sempre positivo e pode usar um 
fator de escala diferente para cada um dos componentes do vetor. Se todos os fatores 
forem iguais, a transformação é chamada de escala uniforme, caso contrário, é chamada 
de escala não uniforme. Uma escala não uniforme pode ser utilizada para deixar um 
objeto com o dobro da altura porém com metade da largura, por isso a escala é 
considerada uma transformação de deformação. 

Como um ponto por si só não possui um comprimento, o que a escala efetivamente faz é 
alterar a distância relativa desse ponto de um outro ponto $C_s$, conhecido como o 
centro da escala, geralmente coincidindo com o centro de um objeto. Para um conjunto 
de pontos, a escala irá alterar a distância relativa entre eles, porém irá manter a 
mesma forma relativa. 

A transformação de escala é representada por uma matriz da seguinte maneira:

\begin{equation}
    \begin{bmatrix}
        a & 0 & 0 & 0\\
        0 & b & 0 & 0\\
        0 & 0 & c & 0\\
        0 & 0 & 0 & 1\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Onde $a$, $b$ e $c$ são os fatores de escala nas direções $x$, $y$ e $z$, 
respectivamente.

\subsection{Quaternions}

Quaternions, aparte de sua definição matemática, são estruturas que possuem quatro 
elementos, e são utilizados em aplicações gráficas pois são capazes de realizar 
rotações em objetos sem o problema do \textit{Gimbal Lock}, no qual uma certa sequência 
de rotações faz com que dois eixos se alinhem, resultando na perda de um grau de 
liberdade. 

Os quaternions são definidos pelos seguintes quatro elementos: 

\begin{equation}
    q = w + xi + yj + zk
\end{equation}

\vspace{.5cm}

Os componentes $i$, $j$ e $k$ podem ser considerados a base padrão para todos os 
quaternions, então essa representação pode ser simplificada como: 

\begin{equation}
    \begin{aligned}
        q = (w, x, y, z)\\
        ou\\
        q = (w,v)
    \end{aligned}
\end{equation}

\vspace{.5cm}

Onde $w$ é a parte escalar, e $v$ a parte vetorial. 

Além de evitar o \textit{Gimbal Lock}, os quaternions podem realizar rotações em torno 
de eixos arbitrários pois podem ser construídos a partir de um ângulo e um eixo. A 
partir de um ângulo $\theta$ e um eixo $k$, um quaternion é construído da seguinte 
forma:

\begin{equation}
    \begin{aligned}
        w = \cos (\theta / 2)\\
        x = k_x \cdotp \sin (\theta / 2)\\
        y = k_y \cdotp \sin (\theta / 2)\\
        z = k_z \cdotp \sin (\theta / 2)\\
    \end{aligned}
\end{equation}

\vspace{.5cm}

De maneira análoga aos vetores, quaternions também podem ser somados entre si e 
multiplicados por um escalar. 

Sua fórmula de norma também é semelhante:

\begin{equation}
    \begin{aligned}
        ||q|| = \sqrt{(w^2 + x^2 + y^2 + z^2)}
    \end{aligned}
\end{equation}

\vspace{.5cm}

Um quaternion normalizado $q'$ é igual a:

\begin{equation}
    \begin{aligned}
        q' = \frac{q}{||q||}
    \end{aligned}
\end{equation}

\vspace{.5cm}

O seu produto escalar também é semelhante ao dos vetores: 

\begin{equation}
    \begin{aligned}
        q_1 \cdotp q_2 = w_1w_2 + x_1x_2 + y_1y_2 + z_1z_2
    \end{aligned}
\end{equation}

Uma característica importante dos quaternions é que estes podem ser convertidos para 
uma matriz, sendo possível combiná-los com outras transformações, a versão matricial 
toma a seguinte forma: 

\begin{equation}
    M_q = 
    \begin{bmatrix}
        1 - 2y^2 - 2z^2 & 2xy - 2wz & 2xz + 2wy\\
        2xy + 2wz & 1 - 2x^2 - 2z^2 & 2yz - 2wx\\
        2xz - 2wy & 2yz + 2wx & 1 - 2x^2 - 2y^2\\
    \end{bmatrix}
\end{equation}

\vspace{.5cm}

Para transformá-lo em matriz, o quaternion deve estar normalizado.

Assim como matrizes, quaternions também podem ser concatenados multiplicando-os, 
permitindo dessa maneira combinações de transformações sucessivas. A concatenação é 
dada por:

\begin{equation}
    \begin{aligned}
        q_2 \times q_1 = (w_1w_2 - v_1 \cdotp v_2, w_1v_2 + w_2v_1 + v_2 \times v_1)
    \end{aligned}
\end{equation}

\section{Modelagem Orientada a Dados}
\label{secdataorienteddesign}

A modelagem orientada a dados (do inglês: \textit{Data Oriented Design}) é 
uma forma de codificar os programas que propõe uma mudança no foco da 
implementação, ao invés de se focar no código, o foco deve estar nos 
dados.

Apesar do termo "orientação a dados" ter sido usado apenas recentemente, a utilização 
dos conceitos dessa técnica já têm sido usados há muito mais tempo do que a introdução 
do termo.

Um exemplo é o trabalho de Chellappa et al.~\cite{chellappa2008write}, no 
qual é reconhecido o problema da velocidade de acesso à memória principal pelo 
processador, e para solucionar esse problema é dito que os dados de uma aplicação devem 
ser lidos na ordem apropriada. Pois as otimizações feitas pelos compiladores são 
limitadas para o caso da leitura da memória já que para realizar esse tipo de 
otimização seria necessário conhecimento do domínio do problema e dos algoritmos 
utilizados, algo que os compiladores não possuem. 

Além disso é reconhecido pelos autores o fato de um \textit{cache miss} causar a perda de 
ciclos e consequentemente a perda de operações de ponto flutuante. Para demonstração do 
problema e sua solução através da reestruturação de código, são mostrados no artigo 
dois algoritmos diferentes. Um deles é de particular interesse para esse trabalho, que 
é a multiplicação entre matrizes pois conforme visto na seção~\ref{secmathconcepts}, 
operações de álgebra linear são extensivamente utilizadas em aplicações gráficas.

Como as otimizações feitas pelo compilador são limitadas, é necessário estruturar o 
código de maneira inteligente para que o acesso à memória seja o menos frequente o 
possível e para aprimorar a coerência de cache, e é para esse aspecto que a MOD serve.

Ao se modelar o código através de uma abordagem orientada a objetos, esta modelagem 
é centrada em volta do problema e da sua solução. Os objetos, que não são coisas reais, 
mas sim o resultado das soluções para o problema apresentado, manipulam apenas os dados 
necessários para representá-los sem nenhuma consideração pelo hardware, pelos 
padrões de dados reais ou de quantidades, por isso essa abordagem permite uma rápida 
prototipagem dos programas pois essas soluções podem ser escritas diretamente da 
modelagem para o código~\cite{fabiandod}.

A MOD utiliza uma abordagem diferente, ao invés de assumir conhecimento nenhum sobre 
o hardware, assume conhecimento nenhum sobre o problema, deixando-a para a 
documentação. Prevendo onde os dados são mais vistos ou esperados, utiliza o input 
mais provável para direcionar a escolha do algoritmo. Com isso, ao se utilizar essa 
abordagem pode-se separar os dados mais utilizados dos menos utilizados de tal forma 
que estes não sejam desnecessariamente carregados da memória.

\begin{figure}[h]
\centering
    \begin{minipage}[b]{0.35\textwidth}
        \includegraphics[width=\textwidth]{../figuras/objectreadingorder}
    \end{minipage}
    \begin{minipage}[b]{0.35\textwidth}
        \includegraphics[width=\textwidth]{../figuras/dodreadingorder}
    \end{minipage}
    \caption{Orientação a objetos vs. Orientação a Dados. Duas maneiras diferentes de 
    se ler os dados da memória.}
    Disponível em: <http://gamesfromwithin.com/data-oriented-design>. Acesso em: 27/05/2017.
    \label{oodvsdod}
\end{figure}

A figura~\ref{oodvsdod} apresenta duas maneiras diferentes de se ler dados da memória, 
a primeira ocorre com a programação orientada a objetos, na qual os dados não são lidos 
de maneira contígua, a sequência de chamadas da figura ocorre para todos os objetos 
caso uma função ou uma rotina chame todos os objetos daquele tipo, o que não é uma 
situação incomum de se acontecer. É preciso passar por todas as referências caso seja 
necessário acessar os dados nos níveis mais baixos da árvore, e se uma função usar
somente alguns desses elementos, essa leitura de dados não é muito eficiente. 

Na segunda figura há uma separação do objeto em componentes diferentes, e componentes 
do mesmo tipo são agrupados juntos na memória, independentemente do objeto de qual 
vieram. Essa organização resulta em blocos largos de dados homogêneos, permitindo o 
uso eficiente de memória através processamento contíguo de dados. 

\section{Linguagem de Programação Rust}

Rust é uma linguagem de programação nova, seu primeira versão estável foi lançada em 2015.
É desenvolvida pelo grupo de pesquisa \textit{Mozilla}~\cite{rustdocs}. Foi projetada 
para ser uma linguagem de sistemas de propósito geral e multiparadigma, tomando influências 
tanto de linguagens imperativas quanto de linguagens funcionais, por exemplo algumas das 
funcionalidades de linguagens funcionais como Haskell ou ML: tipos de dados algébricos, 
casamento de padrões e polimorfismo restringido. A diferença é que Rust é capaz de oferecer 
essas funcionalidades com um completo controle do \textit{layout} da memória e de sua 
alocação, assim como C e C++~\cite{holk2013}.

Os objetivos nos quais a linguagem foca são: segurança, velocidade e concorrência, sem a 
utilização de um \textit{garbage collector}, permitindo a escrita de código de baixo 
nível eficiente com diversas verificações de segurança em tempo de compilação que não causam 
sobrecargas e ainda elimina todas as condições de concorrência~\cite{rustdocs}. 

Um dos motivos pelo qual a linguagem foi desenvolvida foi uma resposta ao fato de que C e 
C++, mesmo sendo rápidas, não são seguras nem ergonômicas, e particularmente ineficiente para 
concorrência. Apesar de ter sido estabilizada apenas há pouco tempo, seus objetivos são 
ambiciosos e a linguagem tem apresentado excelente desempenho. Seu código tem segurança de 
memória por padrão, mais rápido que C++, mais fácil de manter e excelente em 
concorrência~\cite{Beingessner2016}.

A linguagem atinge seus objetivos de velocidade e segurança de memória através de dois 
conceitos: abstrações sem custo e \textit{posse}. Esses dois conceitos serão explicados 
a seguir.

\subsection{Abstrações Sem Custo}

Rust é capaz de fazer otimizações agressivas na compilação para permitir a construção de 
abstrações de alto nível que são transformadas em código de nível mais baixo. Além disso 
a linguagem possui um sistema de traços, o qual possui um alto poder de expressividade 
que permite a construção de abstrações. O sistema de traços é utilizado para escrever 
funções genéricas que podem ser utilizadas para inúmeros tipos de dados diferentes. Quando 
uma dessas funções é chamada para algum tipo de dado específico, o compilador gera uma 
variante daquela função a qual terá ligação estática total, permitindo a aplicação de 
otimizações~\cite{holk2013}.

\subsection{Posse}

O modelo de posse da linguagem possui dois aspectos principais: controlar onde e quando os 
dados vivem, e controlar onde e quando uma mudança pode ocorrer. Esses aspectos são 
garantidos por três funcionalidades principais: tipos afins, escopo e 
privacidade~\cite{Beingessner2016}.

Tipos afins representa valores que são de propriedade exclusiva. Se uma variável que possui 
uma coleção for passado por valor a uma função, ou se sua coleção for atribuída a outra 
variável, a variável original perde a posse da coleção e o seu acesso.

Escopos e privacidade são dois conceitos mais presentes em outras linguagens. Os escopos 
definem uma região na qual os ponteiros que estão nela são validos somente nesta região e 
o compilador garante que os ponteiros não vão extender seu ciclo de vida para além dela. No 
Rust essas regiões são definias por escopos léxicos. Por fim a privacidade é um conceito 
presente em muitas outras linguagens, campos e funções podem ser marcados como sendo públicos 
ou privados, e apenas o código que está dentro de certos limites pode ter acesso a qualquer 
coisa que esteja marcada como privada.

\section{Renderizador Gráfico de Baixo Nível}

\section{Matriz de Transformação}

\section{Matriz de Visualização}

\section{Matriz de Projeção}

\section{O \textit{Pipeline} de Visualização}

\section{O \textit{Pipeline} de Renderização}

\section{Malhas de Polígono}

\section{Shaders}

\section{Iluminação}

\section{O Loop de Jogo}

\chapter{Trabalho Proposto}
\label{cap3}

Neste capítulo será explicado a proposta deste trabalho, um motor de jogos escrito em Rust 
com modelagem orientada a dados visando à otimização da comunicação entre o processador e 
a memória.

Além de utilizar os conceitos da modelagem orientada a dados, também fora necessário utilizar 
conceitos de computação gráfica, álgebra linear e geometria analítica, teoria de grafos, 
processamento de imagens, física, entre outros.

Conforme explicado na seção~\ref{secgameengine}, um motor de jogos é uma combinação de 
diversos componentes diferentes que juntos compõem a parte lógica de um jogo digital. As 
seções seguintes discutirão sobre os componentes implementados que foram julgados necessários 
para o desenvolvimento do motor de jogos que é o objeto de estudo deste trabalho.

Além dos componentes, também serão explicadas as estratégias empregadas para a implementação 
de outros elementos importantes discutidos previamente no capítulo~\ref{cap2}
que fazem parte da estrutura de um motor de jogos, como o \textit{pipeline} de renderização 
e o loop de jogo.

\section{Biblioteca Matemática}

Utilizando algumas das utilidades mencionadas na seção~\ref{secmathconcepts}, foi implementada 
uma biblioteca matemática o mais minimalista o possível, contendo somente as estruturas 
necessárias para se realizar os testes e obter os resultados desejados deste trabalho. 

\subsection{Outras Utilidades Matemáticas}

\section{Componente Gráfico}

\subsection{Câmera}

\subsection{Grafo de Cenas}

\subsection{Otimizações de Renderização}

\section{Gerenciador de Recursos}

\chapter{Trabalhos Relacionados}
\label{cap4}
