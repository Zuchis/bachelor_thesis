\setlength\abovedisplayskip{0pt} \setlength\belowdisplayskip{0pt}
\setlength\abovedisplayshortskip{0pt} \setlength\belowdisplayshortskip{0pt}

\chapter{Fundamenta\c{c}\~ao Te\'orica}
\label{cap2}

Neste capítulo serão discutidos e explicados todos os conceitos e 
fundamentação teórica necessários para a compreensão da proposta 
feita nesse trabalho, assim como a abordagem que será utilizada 
para a implementação de todos os componentes que juntos vão compor 
o motor de jogos que será o objeto de estudo deste trabalho.

\section{Comunicação Entre o Processador e a Memória}

\subsection{Gargalo do Processador-Memória}

\section{Motor de Jogos}
\label{secgameengine}

O termo e o conceito de motor de jogos surgiram no início da década de 1990, quando a 
empresa \textit{Id Software} lançou o jogo \textit{DOOM} e, juntamente com ele, seu 
motor de jogos conhecido como \textit{DOOM Engine}, que depois foi nomeado como 
\textit{Id Tech 1}~\cite{gregory2009game}.

O jogo \textit{DOOM}, através da \textit{Id Tech 1}, é considerado o primeiro jogo da 
indústria de jogos digitais que possui uma clara separação entre os componentes núcleo 
do jogo, chamada de parte lógica, dos componentes criativos, tais como animações, 
modelos geométricos, sons, imagens, planos de fundo, música, etc.

A \textit{Id Software}, além de ter criado um novo conceito de \textit{software} 
na indústria de jogos que atualmente é considerado padrão em grandes empresas e ter 
gerado uma vasta família de motores de jogos que partiram da \textit{Id Tech 1}, também 
conceberam um novo paradigma para se desenvolver jogos digitais, onde a produção de todo 
o conteúdo lógico é independentemente e separadamente feita dos componentes criativos.

A maior vantagem da utilização de motores de jogos consiste na reutilização de código. 
Isso significa que, para rotinas parecidas, ou até mesmo para outros projetos, um mesmo 
código pode ser utilizado mudando-se apenas alguns parâmetros. Além disso, motores de 
jogos mais completos geralmente permitem uma rápida prototipagem de novos projetos,
requer uma habilidade menor por parte dos programadores e minimiza seus esforços 
através de abstrações.

A implementação de um motor de jogos é feito através do desenvolvimento separado de 
diversos componentes. Cada componente é responsável por uma parte específica da parte 
lógica do jogo, ao oposto do que era feito na programação de jogos tradicional, cujo 
objetivo primário era maximizar o desempenho para o hardware utilizado. Essa preocupação 
com o desempenho, juntamente com o curto intervalo de tempo que os desenvolvedores tinham 
para terminar os projetos geralmente resultava em códigos que não ficavam conforme os 
preceitos de boa engenharia de software segundo Kruchten~\cite{Kruchten2006}.

Dada a complexidade que é desenvolver um motor de jogos, considerando todos os aspectos que 
esta deve abranger, desenvolver um código monolítico sem estrutura arquitetural e sem se 
preocupar com o design geral do sistema, implica em um \textit{software} cujos componentes 
são todos dependentes entre si. O resultado dessa dependência é um sistema frágil, no qual 
pequenas mudanças em alguma parte do código pode afetar outras partes de maneiras não 
óbvias, além de desencorajar os programadores de alterar o código ou refatorá-lo para 
aumentar sua qualidade~\cite{Keenan2011}.

Por esse motivo, é importante que um motor de jogos esteja devidamente modularizado para 
evitar um sistema frágil, e facilitar a adição de novos componentes. É importante lembrar 
que, apesar de ser desejável que os componentes estejam o mais independentes o possível 
entre si, estes devem estar funcionando perfeitamente em sinergia, isto é, um motor de 
jogos não funciona com vários componentes executando separadamente, mas sim com a 
comunicação entre eles de maneira clara e eficiente.

A comunicação e integração entre os diferentes componentes de um motor de jogos faz parte 
da modelagem da arquitetura deste. Conforme apontado por Anderson et 
al.~\cite{Anderson2008}, um problema que ainda persiste atualmente é a falta de material 
na literatura a respeito da modelagem da arquitetura de motores de jogos, sendo que a 
maior parte da pesquisa disponível foca somente nos componentes separados, como 
renderização, inteligência artificial (IA) ou rede. Ainda é salientado pelo autor que 
ainda não há um consenso sobre os limites que separam um jogo do seu motor, portanto 
há espaço a ser explorado nessa área.

A quantidade de componentes presentes em um motor de jogos é altamente dependente da 
complexidade desejada para o jogo sendo desenvolvido, alguns dos componentes mais 
presentes são: componente gráfico, colisões, física, inteligência artificial, rede, som 
e animação.

\section{Conceitos Matemáticos}
\label{secmathconcepts}

Qualquer motor de jogos necessita de uma biblioteca matemática, uma vez que 
jogos são aplicações as quais são extremamente dependentes de operações e 
conceitos matemáticos. 

Essas bibliotecas fornecem diversas utilidades, algoritmos e funções 
matemáticas, tais como: estruturas de dados personalizadas de vetores, 
matrizes e quaternions; operações matriciais e vetoriais; rotações e 
interpolações de quaternions; trigonometria; operações geométricas com 
linhas, raios, esferas, etc., manipulação de \textit{splines}, integração 
numérica, e quaisquer outras utilidades que os desenvolvedores 
necessitarem~\cite{gregory2009game}.

A área da computação gráfica está intimamente ligada às áreas da matemática de 
álgebra linear e geometria analítica, a maior parte dos conceitos matemáticos empregados 
neste trabalho pertencem a uma destas áreas. Visto que ambas estas áreas são vastas e vão 
muito além do escopo deste trabalho, o restante desta seção tratará dos conceitos e 
propriedades que são relevantes para a computação gráfica apenas.

Verth e Bishop~\cite{Verth:2008} e Mortenson~\cite{mortenson1999mathematics} fizeram uma 
excelente cobertura de toda a matemática essencial utilizada em motores de jogos. O restante 
da seção cobrirá os tópicos mais importantes desses trabalhos cujos conceitos são utilizados 
para a elaboração da biblioteca matemática presente neste trabalho.

\subsection{Vetores e Pontos}

Vetores e pontos são as estruturas essenciais de todos os objetos presentes em 
aplicações gráficas. 

Os pontos representam posições do espaço, podem ser utilizados para determinar os 
vértices da superfície de um objeto, que consequentemente determinará seu formato 
(chamado de modelo), e também podem representar a posição de um objeto no espaço, 
essa posição geralmente se refere ao centro do objeto. Se os pontos de um objeto 
forem alterados, o modelo desse objeto também será alterado.

Vetores (no campo da geometria) são entidades que possuem uma direção e um comprimento, 
chamado de magnitude e representam a diferença entre dois pontos. São utilizados para 
armazenar grandezas (como velocidade, gravidade, aceleração, atrito, etc.) e direções.

Há alguns casos específicos de vetores que recebem nomeações 
diferentes, por exemplo vetores cuja magnitude é igual a 1 são chamados de vetores 
unitários ou vetores normalizados. Um vetor cuja magnitude é igual a 0 é chamado de 
vetor zero, e não possui nenhuma direção. 

Para representar um vetor no computador, utiliza-se a chamada "base Euclidiana padrão", 
composta pelos três vetores unitários linearmente independentes $i$, $j$ e $k$ que são 
perpendiculares entre si para o caso do espaço tridimensional $\mathbb{R}^3$, para o 
espaço bidimensional $\mathbb{R}^2$, utiliza-se somente os vetores $i$ e $j$. 

Utilizando essa base, pode-se representar unicamente qualquer vetor no espaço através 
de uma combinação linear dos três vetores base da seguinte maneira: 

\begin{equation}
    \centering
    v = xi + yj + zk
\end{equation}

Os coeficientes $x$, $y$ e $z$ representam o deslocamento em cada um dos eixos. A 
figura~\ref{3dbasisvector} demonstra como um vetor é representado utilizando a base 
Euclidiana padrão. Esses coeficientes são utilizados para representar um vetor 
algebricamente através de uma tripla $(x,y,z)$, ou uma dupla para o caso dos vetores 
2D, e são conhecidos como componentes do vetor.

\begin{figure}[h]
    \centering
    \includegraphics[width =.6\textwidth]{../figuras/3dbasisvector}
    \caption{Representação de um Vetor na Base Tridimensional.}
    Fonte: \cite{Verth:2008}.
    \label{3dbasisvector}
\end{figure}

Com essa representação algébrica, pode-se definir as operações sobre vetores tão 
utilizadas na computação gráfica 

\subsection{Operações Sobre Vetores}

Nesta seção serão apresentadas operações que podem ser feitas sobre vetores e entre 
vetores. Para todas as operações serão utilizados como exemplo vetores no espaço 3D.
\subsubsection{Adição}

A adição entre dois vetores é feita através da soma de cada um dos componentes de um 
vetor com os componentes correspondentes do outro vetor.

\begin{equation}
    \begin{aligned}
        v1 + v2 = (x_1, y_1, z_1) + (x_2, y_2, z_2) \\
        v1 + v2 = (x_1 + x_2, y_1 + y_2 , z_1 + z_2)
    \end{aligned}
\end{equation}

\subsubsection{Subtração}

A subtração entre dois vetores é semelhante à adição, porém são feitas operações de 
substrações entre os componentes dos operandos.

\begin{equation}
    \begin{aligned}
        v1 - v2 = (x_1, y_1, z_1) - (x_2, y_2, z_2) \\
        v1 - v2 = (x_1 - x_2, y_1 - y_2, z_1 - z_2)
    \end{aligned}
\end{equation}

Observa-se que assim como a subtração entre escalares, a subtração entre vetores também 
não é comutativa.

\subsubsection{Multiplicação por Escalar}

Dado um certo coeficiente $k$, a multiplicação de um vetor $v$ pelo escalar $k$ é dada 
pela multiplicação do escalar por cada um dos componentes do vetor:

\begin{equation}
    \begin{aligned}
        kv = k(x, y, z)\\
        kv = (kx, ky, kz)
    \end{aligned}
\end{equation}

\subsubsection{Igualdade Entre Vetores}

Um vetor $v1$ é igual a um vetor $v2$, se todos os componentes de $v1$ forem iguais aos 
componentes correspondentes de $v2$. 

\begin{equation}
    \begin{aligned}
        v1 = v2\\
        (x_1, y_1, z_1) = (x_2, y_2, z_2)\\
        x_1 = x_2, y_1 = y_2, z_1 = z_2
    \end{aligned}
\end{equation}

\subsubsection{Magnitude}

O operador de magnitude serve para calcular o comprimento de um vetor. Para o fazê-lo, 
a norma utilizada é a norma Euclidiana, cujo cálculo consiste na raiz quadrada da soma  
dos quadrados dos componentes. O operador de norma é denotado por: $||v||$. Dado um 
vetor $v$, o tamanho do vetor $d$ é dado por:

\begin{equation}
    \begin{aligned}
        ||v|| = d = \sqrt{x^2 + y^2 + z^2}
    \end{aligned}
\end{equation}

\subsubsection{Normalização}

A normalização de um vetor cria um vetor unitário $v'$ a partir de um vetor $v$, 
mudando sua magnitude para 1, porém mantendo sua direção. Isso é feito a partir da
divisão de um vetor pela sua norma:

\begin{equation}
    \begin{aligned}
        v' = \frac{v}{||v||}
    \end{aligned}
\end{equation}

\subsubsection{Produto Escalar}

O produto escalar entre dois vetores, como o nome sugere, resulta em um escalar a partir 
dos operandos, a operação é feita multiplicando-se os dois vetores 
componente-a-componente e depois somando os resultados:

\begin{equation}
    \begin{aligned}
        v1 \cdotp v2 = v1_xv2_x + v1_yv2_y + v1_zv2_z
    \end{aligned}
\end{equation}

Se os vetores $v1$ e $v2$ formarem um ângulo de 90 graus entre si, então o produto 
escalar entre eles será zero. Então pode-se dizer que dois vetores serão 
perpendiculares, ou ortogonais, quando $v1 \cdotp v2 = 0$.

Além de verificar a ortogonalidade entre dois vetores, o produto escalar pode fornecer 
outras informações, por exemplo, se $v1 \cdotp v2 > 0$, então o ângulo entre eles é 
menor do que 90 graus, se $v1 \cdotp v2 < 0$, então o ângulo entre eles é maior do que 
90 graus, esse teste não requer que os vetores estejam normalizados.

\subsubsection{Produto Vetorial}

O produto vetorial, opostamente ao produto escalar, tem como resultado da operação um 
vetor. O vetor resultante $w$ do produto vetorial entre $v1$ e $v2$ será sempre 
ortogonal a estes. Como essa operação não é comutativa, a direção do vetor resultante 
dependerá da ordem dos operandos, ou seja, há duas saídas possíveis dessa operação, uma 
é a negação da outra. O produto vetorial é determinado pela fórmula:

\begin{equation}
    \begin{aligned}
        v1 \times v2 = (v1_yv2_z - v2_yv1_z, v1_zv2_x - v2_zv1_x, v1_xv2_y - v2_xv1_y)
    \end{aligned}
\end{equation}

A figura~\ref{piccrossproduct} demonstra geometricamente um produto vetorial. Os usos mais 
comuns para o produto vetorial é para gerar um vetor ortogonal a outros dois e para 
verificar se dois vetores são paralelos entre si.

Diferentemente do produto escalar, o produto vetorial não é definido para vetores 2D.

\begin{figure}[h]
    \centering
    \includegraphics[width =.4\textwidth]{../figuras/crossproduct}
    \caption{Produto vetorial com os dois possíveis resultados representados.}
    Disponível em: <https://en.wikipedia.org/wiki/Cross\_product>. Acesso em: 27/05/2017.
    \label{piccrossproduct}
\end{figure}

\subsection{Matrizes}

Matrizes são \textit{arrays} bidimensionais nas quais cada valor individual é chamado de 
elemento. A descrição de uma matriz é feita especificando o seu número de linhas e número 
de colunas, sendo $m$ o número de linhas e $n$ o número de colunas, é dito que é uma matriz 
$m$ por $n$, denotado por $m\ x\ n$. A relação da quantidade de linhas e colunas é também 
conhecida como o tamanho da matriz.

Uma linha é uma sequência de elementos na horizontal da esquerda para a direita, enquanto 
que uma coluna é uma sequência de elementos na vertical de cima para baixo. Para 
referenciar um elemento específico de uma matriz $A$, usa-se a notação: $a_{i,j}$, onde 
$i$ referencia uma linha e $j$ uma coluna. Dessa maneira, o elemento $a_{1,2}$ é o elemento 
que está na primeira linha e na segunda coluna na matriz A.

Alguns casos específicos de matrizes recebem denotações especiais. A seguir serão listados 
alguns caso específicos de matrizes:
\begin{itemize}
    \item Matriz quadrada: matriz cujo número de linhas é igual ao número de colunas 
    \item Matriz zero: matriz na qual todos os elementos são iguais a zero
    \item Matriz Identidade: matriz na qual todos os elementos da diagonal principal são 
        iguais a um, e o restante igual a zero
    \item Matriz coluna: matriz que só possui uma coluna de elementos
    \item Matriz linha: matriz que só possui uma linha de elementos
\end{itemize}

Existem outros casos específicos de matrizes, como matrizes triangulares,  mas não são tão 
importantes quanto estas.

O conjunto de elementos os quais o número da linha é igual ao número da coluna (ex: 
$a_{1,1}$) é chamado de diagonal principal.

\subsection{Operações Sobre Matrizes}

Nesta seção serão apresentadas operações feitas sobre matrizes, entre matrizes e também 
entre matrizes e vetores.

\subsubsection{Adição e Subtração}

Dadas duas matrizes $A$ e $B$, a soma entre elas é feita de maneira semelhante à soma de 
vetores, soma-se componente-a-componente. Sendo $S$ a soma de $A$ e $B$, teremos:

\begin{equation}
    \begin{aligned}
        S = A + B\\
        s_{i,j} = a_{i,j} + b_{i,j}
    \end{aligned}
\end{equation}

A subtração é feita de maneira semelhante, subtraindo-se os componentes ao invés de 
somá-los. Assim como números reais e vetores, a subtração não é comutativa para matrizes.

Nota-se que para realizar essas operações, os tamanhos de $A$, $B$ e $S$ devem ser 
iguais. 

\subsubsection{Multiplicação por Escalar}

De maneira similar à multiplicação de um vetor por um escalar, dado um escalar $k$, 
cada elemento da matriz é multiplicado por $k$. Sendo $P$, a multiplicação da matrix $A$ 
pelo escalar $k$, esta é dada por:

\begin{equation}
    \begin{aligned}
        P = kA\\
        p_{i,j} = k \dot a_{i,j}
    \end{aligned}
\end{equation}

\subsubsection{Matriz Transposta}

A transposta de uma matriz $A$, denotada por $A^T$, troca as linhas pelas colunas de $A$ 
e vice-versa. Isso é feito trocando os elementos ao longo da diagon 

\subsection{Quaternions}

\subsection{Transformações}

\section{Modelagem Orientada a Dados}
\label{secdataorienteddesign}

A modelagem orientada a dados (do ingles: \textit{Data Oriented Design}) é 
uma forma de codificar os programas que propõe uma mudança no foco da 
implementação, ao invés de se focar no código, o foco deve estar nos 
dados.

Apesar do termo "orientação a dados" ter sido usado apenas recentemente, a utilização dos 
conceitos dessa técnica já têm sido usados há muito mais tempo do que a introdução do termo.

Um exemplo é o trabalho de Chellappa, Franchetti e Püschel~\cite{chellappa2008write}, no qual é 
reconhecido o problema da velocidade de acesso à memória principal pelo processador, e para 
solucionar esse problema é dito que os dados de uma aplicação devem ser lidos na ordem 
apropriada. Pois as otimizações feitas pelos compiladores são limitadas para o caso da 
leitura da memória já que para realizar esse tipo de otimização seria necessário 
conhecimento do domínio do problema e dos algoritmos utilizados, algo que os compiladores 
não possuem. 

Além disso é reconhecido pelos autores o fato de um \textit{cache miss} causar a perda de 
ciclos e consequentemente a perda de operações de ponto flutuante. Para demonstração do 
problema e sua solução através da reestruturação de código, são mostrados no artigo 
dois algoritmos diferentes. Um deles é de particular interesse para esse trabalho, que 
é a multiplicação entre matrizes pois conforme visto na seção~\ref{secmathconcepts}, 
operações de álgebra linear são extensivamente utilizadas em aplicações gráficas.

\section{Linguagem de Programação Rust}

Rust é uma linguagem de programação nova, seu primeira versão estável foi lançada em 2015.
É desenvolvida pelo grupo de pesquisa \textit{Mozilla}~\cite{rustdocs}. Foi projetada 
para ser uma linguagem de sistemas de propósito geral e multiparadigma, tomando influências 
tanto de linguagens imperativas quanto de linguagens funcionais, por exemplo algumas das 
funcionalidades de linguagens funcionais como Haskell ou ML: tipos de dados algébricos, 
casamento de padrões e polimorfismo restringido. A diferença é que Rust é capaz de oferecer 
essas funcionalidades com um completo controle do \textit{layout} da memória e de sua 
alocação, assim como C e C++~\cite{holk2013}.

Os objetivos nos quais a linguagem foca são: segurança, velocidade e concorrência, sem a 
utilização de um \textit{garbage collector}, permitindo a escrita de código de baixo 
nível eficiente com diversas verificações de segurança em tempo de compilação que não causam 
sobrecargas e ainda elimina todas as condições de concorrência~\cite{rustdocs}. 

Um dos motivos pelo qual a linguagem foi desenvolvida foi uma resposta ao fato de que C e 
C++, mesmo sendo rápidas, não são seguras nem ergonômicas, e particularmente ineficiente para 
concorrência. Apesar de ter sido estabilizada apenas há pouco tempo, seus objetivos são 
ambiciosos e a linguagem tem apresentado excelente desempenho. Seu código tem segurança de 
memória por padrão, mais rápido que C++, mais fácil de manter e excelente em 
concorrência~\cite{Beingessner2016}.

A linguagem atinge seus objetivos de velocidade e segurança de memória através de dois 
conceitos: abstrações sem custo e \textit{posse}. Esses dois conceitos serão explicados 
a seguir.

\subsection{Abstrações Sem Custo}

Rust é capaz de fazer otimizações agressivas na compilação para permitir a construção de 
abstrações de alto nível que são transformadas em código de nível mais baixo. Além disso 
a linguagem possui um sistema de traços, o qual possui um alto poder de expressividade 
que permite a construção de abstrações. O sistema de traços é utilizado para escrever 
funções genéricas que podem ser utilizadas para inúmeros tipos de dados diferentes. Quando 
uma dessas funções é chamada para algum tipo de dado específico, o compilador gera uma 
variante daquela função a qual terá ligação estática total, permitindo a aplicação de 
otimizações~\cite{holk2013}.

\subsection{Posse}

O modelo de posse da linguagem possui dois aspectos principais: controlar onde e quando os 
dados vivem, e controlar onde e quando uma mudança pode ocorrer. Esses aspectos são 
garantidos por três funcionalidades principais: tipos afins, escopo e 
privacidade~\cite{Beingessner2016}.

Tipos afins representa valores que são de propriedade exclusiva. Se uma variável que possui 
uma coleção for passado por valor a uma função, ou se sua coleção for atribuída a outra 
variável, a variável original perde a posse da coleção e o seu acesso.

Escopos e privacidade são dois conceitos mais presentes em outras linguagens. Os escopos 
definem uma região na qual os ponteiros que estão nela são validos somente nesta região e 
o compilador garante que os ponteiros não vão extender seu ciclo de vida para além dela. No 
Rust essas regiões são definias por escopos léxicos. Por fim a privacidade é um conceito 
presente em muitas outras linguagens, campos e funções podem ser marcados como sendo públicos 
ou privados, e apenas o código que está dentro de certos limites pode ter acesso a qualquer 
coisa que esteja marcada como privada.

\section{Renderizador Gráfico de Baixo Nível}

\section{Matriz de Transformação}

\section{Matriz de Visualização}

\section{Matriz de Projeção}

\section{O \textit{Pipeline} de Visualização}

\section{O \textit{Pipeline} de Renderização}

\section{Malhas de Polígono}

\section{Texturas}

\section{Shaders}

\section{Iluminação}

\section{O Loop de Jogo}

\chapter{Trabalho Proposto}
\label{cap3}

Neste capítulo será explicado a proposta deste trabalho, um motor de jogos escrito em Rust 
com modelagem orientada a dados visando à otimização da comunicação entre o processador e 
a memória.

Além de utilizar os conceitos da modelagem orientada a dados, também fora necessário utilizar 
conceitos de computação gráfica, álgebra linear e geometria analítica, teoria de grafos, 
processamento de imagens, física, entre outros.

Conforme explicado na seção~\ref{secgameengine}, um motor de jogos é uma combinação de 
diversos componentes diferentes que juntos compõem a parte lógica de um jogo digital. As 
seções seguintes discutirão sobre os componentes implementados que foram julgados necessários 
para o desenvolvimento do motor de jogos que é o objeto de estudo deste trabalho.

Além dos componentes, também serão explicadas as estratégias empregadas para a implementação 
de outros elementos importantes discutidos previamente no capítulo~\ref{cap2}
que fazem parte da estrutura de um motor de jogos, como o \textit{pipeline} de renderização 
e o loop de jogo.

\section{Biblioteca Matemática}

Utilizando algumas das utilidades mencionadas na seção~\ref{secmathconcepts}, foi implementada 
uma biblioteca matemática o mais minimalista o possível, contendo somente as estruturas 
necessárias para se realizar os testes e obter os resultados desejados deste trabalho. 

\subsection{Outras Utilidades Matemáticas}

\section{Componente Gráfico}

\subsection{Câmera}

\subsection{Grafo de Cenas}

\subsection{Otimizações de Renderização}

\section{Gerenciador de Recursos}

\chapter{Trabalhos Relacionados}
\label{cap4}
