\setlength\abovedisplayskip{0pt} \setlength\belowdisplayskip{0pt}
\setlength\abovedisplayshortskip{0pt} \setlength\belowdisplayshortskip{0pt}

\chapter{Fundamenta\c{c}\~ao Te\'orica}
\label{cap2}

Neste capítulo serão discutidos e explicados todos os conceitos e 
fundamentação teórica necessários para a compreensão da proposta 
feita nesse trabalho, assim como a abordagem que será utilizada 
para a implementação de todos os componentes que juntos vão compor 
o motor de jogos que será o objeto de estudo deste trabalho.

\section{Motor de Jogos}
\label{secgameengine}

\section{Conceitos Matemáticos}
\label{secmathconcepts}

Qualquer motor de jogos necessita de uma biblioteca matemática, uma vez que 
jogos são aplicações as quais são extremamente dependentes de operações e 
conceitos matemáticos. 

Essas bibliotecas fornecem diversas utilidades, algoritmos e funções 
matemáticas, tais como: estruturas de dados personalizadas de vetores, 
matrizes e quaternions; operações matriciais e vetoriais; rotações e 
interpolações de quaternions; trigonometria; operações geométricas com 
linhas, raios, esferas, etc., manipulação de \textit{splines}, integração 
numérica, e quaisquer outras utilidades que os desenvolvedores 
necessitarem~\cite{gregory2009game}.

A área da computação gráfica está intimamente ligada às áreas da matemática de 
álgebra linear e geometria analítica, a maior parte dos conceitos matemáticos empregados 
neste trabalho pertencem a uma destas áreas. Visto que ambas estas áreas são vastas e vão 
muito além do escopo deste trabalho, o restante desta seção tratará dos conceitos e 
propriedades que são relevantes para a computação gráfica apenas.

Verth e Bishop~\cite{Verth:2008} fizeram uma excelente cobertura de toda a matemática 
essencial utilizada em motores de jogos. O restante da seção cobrirá os tópicos mais 
importantes do trabalho deles cujos conceitos são utilizados para a elaboração da 
biblioteca matemática presente neste trabalho.

\subsection{Vetores e Pontos}

Vetores e pontos são as estruturas essenciais de todos os objetos presentes em 
aplicações gráficas. 

Os pontos representam posições do espaço, podem ser utilizados para determinar os 
vértices da superfície de um objeto, que consequentemente determinará seu formato 
(chamado de modelo), e também podem representar a posição de um objeto no espaço, 
essa posição geralmente se refere ao centro do objeto. Se os pontos de um objeto 
forem alterados, o modelo desse objeto também será alterado.

Vetores (no campo da geometria) são entidades que possuem uma direção e um comprimento, 
chamado de magnitude e representam a diferença entre dois pontos. São utilizados para 
armazenar grandezas (como velocidade, gravidade, aceleração, atrito, etc.) e direções.

Há alguns casos específicos de vetores que recebem nomeações 
diferentes, por exemplo vetores cuja magnitude é igual a 1 são chamados de vetores 
unitários ou vetores normalizados. Um vetor cuja magnitude é igual a 0 é chamado de 
vetor zero, e não possui nenhuma direção. 

Para representar um vetor no computador, utiliza-se a chamada "base Euclidiana padrão", 
composta pelos três vetores unitários linearmente independentes $i$, $j$ e $k$ que são 
perpendiculares entre si para o caso do espaço tridimensional $\mathbb{R}^3$, para o 
espaço bidimensional $\mathbb{R}^2$, utiliza-se somente os vetores $i$ e $j$. 

Utilizando essa base, pode-se representar unicamente qualquer vetor no espaço através 
de uma combinação linear dos três vetores base da seguinte maneira: 

\begin{equation}
    \centering
    v = xi + yj + zk
\end{equation}

Os coeficientes $x$, $y$ e $z$ representam o deslocamento em cada um dos eixos. A 
figura~\ref{3dbasisvector} demonstra como um vetor é representado utilizando a base 
Euclidiana padrão. Esses coeficientes são utilizados para representar um vetor 
algebricamente através de uma tripla $(x,y,z)$, ou uma dupla para o caso dos vetores 
2D, e são conhecidos como componentes do vetor.

\begin{figure}[h]
    \centering
    \includegraphics[width =.6\textwidth]{../figuras/3dbasisvector}
    \caption{Representação de um Vetor na Base Tridimensional.}
    Fonte: \cite{Verth:2008}.
    \label{3dbasisvector}
\end{figure}

Com essa representação algébrica, pode-se definir as operações sobre vetores tão 
utilizadas na computação gráfica 

\subsection{Operações Sobre Vetores}

Nesta seção serão apresentadas operações que podem ser feitas sobre vetores e entre 
vetores. Para todas as operações serão utilizados como exemplo vetores no espaço 3D, 
e serão representados por $v$, $v1$ e $v2$.

\subsubsection{Adição}

A adição entre dois vetores é feita através da soma de cada um dos componentes de um 
vetor com os componentes correspondentes do outro vetor.

\begin{equation}
    \begin{aligned}
        v1 + v2 = (x_1, y_1, z_1) + (x_2, y_2, z_2) \\
        v1 + v2 = (x_1 + x_2, y_1 + y_2 , z_1 + z_2)
    \end{aligned}
\end{equation}

\subsubsection{Subtração}

A subtração entre dois vetores é semelhante à adição, porém são feitas operações de 
substrações entre os componentes dos operandos.

\begin{equation}
    \begin{aligned}
        v1 - v2 = (x_1, y_1, z_1) - (x_2, y_2, z_2) \\
        v1 - v2 = (x_1 - x_2, y_1 - y_2, z_1 - z_2)
    \end{aligned}
\end{equation}

Observa-se que assim como a subtração entre escalares, a subtração entre vetores também 
não é comutativa.

\subsubsection{Multiplicação por Escalar}

Dado um certo coeficiente $k$, a multiplicação de um vetor $v$ pelo escalar $k$ é dada 
pela multiplicação do escalar por cada um dos componentes do vetor:

\begin{equation}
    \begin{aligned}
        kv = k(x, y, z)\\
        kv = (kx, ky, kz)
    \end{aligned}
\end{equation}

\subsubsection{Igualdade Entre Vetores}

Um vetor $v1$ é igual a um vetor $v2$, se todos os componentes de $v1$ forem iguais aos 
componentes correspondentes de $v2$. 

\begin{equation}
    \begin{aligned}
        v1 = v2\\
        (x_1, y_1, z_1) = (x_2, y_2, z_2)\\
        x_1 = x_2, y_1 = y_2, z_1 = z_2
    \end{aligned}
\end{equation}

\subsubsection{Magnitude}

O operador de magnitude serve para calcular o comprimento de um vetor. Para o fazê-lo, 
a norma utilizada é a norma Euclidiana, cujo cálculo consiste na raiz quadrada da soma  
dos quadrados dos componentes. O operador de norma é denotado por: $||v||$. Dado um 
vetor $v$, o tamanho do vetor $d$ é dado por:

\begin{equation}
    \begin{aligned}
        ||v|| = d = \sqrt{x^2 + y^2 + z^2}
    \end{aligned}
\end{equation}

\subsubsection{Normalização}

A normalização de um vetor cria um vetor unitário $v'$ a partir de um vetor $v$, 
mudando sua magnitude para 1, porém mantendo sua direção. Isso é feito a partir da
divisão de um vetor pela sua norma:

\begin{equation}
    \begin{aligned}
        v' = \frac{v}{||v||}
    \end{aligned}
\end{equation}

\subsubsection{Produto Escalar}

\subsubsection{Produto Vetorial}

\subsection{Matrizes}

\subsection{Quaternions}

\subsection{Transformações Afim}

\section{Modelagem Orientada a Dados}
\label{secdataorienteddesign}

A modelagem orientada a dados (do ingles: \textit{Data Oriented Design}) é 
uma forma de codificar os programas que propõe uma mudança no foco da 
implementação, ao invés de se focar no código, o foco deve estar nos 
dados.

Apesar do termo "orientação a dados"  ter sido usado apenas recentemente, a utilização dos 
conceitos dessa técnica já têm sido usados há muito mais tempo do que a introdução do termo.

Um exemplo é o trabalho de Chellappa, Franchetti e Püschel~\cite{chellappa2008write}, no qual é 
reconhecido o problema da velocidade de acesso à memória principal pelo processador, e para 
solucionar esse problema é dito que os dados de uma aplicação devem ser lidos na ordem 
apropriada. Pois as otimizações feitas pelos compiladores são limitadas para o caso da 
leitura da memória já que para realizar esse tipo de otimização seria necessário 
conhecimento do domínio do problema e dos algoritmos utilizados, algo que os compiladores 
não possuem. 

Além disso é reconhecido pelos autores o fato de um \textit{cache miss} causar a perda de 
ciclos e consequentemente a perda de operações de ponto flutuante. Para demonstração do 
problema e sua solução através da reestruturação de código, são mostrados no artigo 
dois algoritmos diferentes. Um deles é de particular interesse para esse trabalho, que 
é a multiplicação entre matrizes pois conforme visto na seção~\ref{secmathconcepts}, 
operações de álgebra linear são extensivamente utilizadas em aplicações gráficas.

\section{Linguagem de Programação Rust}

\section{Renderizador Gráfico de Baixo Nível}

\section{Matriz de Transformação}

\section{Matriz de Visualização}

\section{Matriz de Projeção}

\section{O \textit{Pipeline} de Visualização}

\section{O \textit{Pipeline} de Renderização}

\section{Malhas de Polígono}

\section{Texturas}

\section{Shaders}

\section{Iluminação}

\section{O Loop de Jogo}

\chapter{Trabalho Proposto}
\label{cap3}

Neste capítulo será explicado a proposta deste trabalho, um motor de jogos escrito em Rust 
com modelagem orientada a dados visando à otimização da comunicação entre o processador e 
a memória.

Além de utilizar os conceitos da modelagem orientada a dados, também fora necessário utilizar 
conceitos de computação gráfica, álgebra linear e geometria analítica, teoria de grafos, 
processamento de imagens, física, entre outros.

Conforme explicado na seção~\ref{secgameengine}, um motor de jogos é uma combinação de 
diversos componentes diferentes que juntos compõem a parte lógica de um jogo digital. As 
seções seguintes discutirão sobre os componentes implementados que foram julgados necessários 
para o desenvolvimento do motor de jogos que é o objeto de estudo deste trabalho.

Além dos componentes, também serão explicadas as estratégias empregadas para a implementação 
de outros elementos importantes discutidos previamente no capítulo~\ref{cap2}
que fazem parte da estrutura de um motor de jogos, como o \textit{pipeline} de renderização 
e o loop de jogo.

\section{Biblioteca Matemática}

Utilizando algumas das utilidades mencionadas na seção~\ref{secmathconcepts}, foi implementada 
uma biblioteca matemática o mais minimalista o possível, contendo somente as estruturas 
necessárias para se realizar os testes e obter os resultados desejados deste trabalho. 

\subsection{Outras Utilidades Matemáticas}

\section{Componente Gráfico}

\subsection{Câmera}

\subsection{Grafo de Cenas}

\subsection{Otimizações de Renderização}

\section{Gerenciador de Recursos}

\chapter{Trabalhos Relacionados}
\label{cap4}
