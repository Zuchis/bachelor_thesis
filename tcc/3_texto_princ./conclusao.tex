\chapter{Conclusão}

A evolução do hardware de computadores chegou a um problema, onde se tem processadores 
extremamente rápidos porém uma velocidade de acesso à memória principal que foi incapaz de 
acompanhar essa evolução. As aplicações de computador que fazem acesso muito frequente à 
memória têm seu desempenho consideravelmente afetado por esse problema e precisa muitas 
vezes recorrer ao paralelismo, o que pode gerar vários problemas incluindo concorrência e 
imprevisibilidade dos dados, pois muitas vezes o paralelismo não estava planejado desde 
o início do projeto.

Jogos são uma categoria de aplicações gráficas que se encaixam nesse problema de acesso 
frequente a memória, isto porque há muitos dados externos que precisam ser carregado na 
aplicação, conhecidos como \textit{assets}, estes dados incluem: malhas, animações, sons, 
música, planos de fundo, fontes, texturas, entre outros. Por isso, são necessárias a 
leitura e armazenamento eficiente destes dados pois o bom desempenho em um jogo é 
essencial para garantir a experiência do jogador.

Existem outras soluções para esse problema além do paralelismo, uma delas foi 
apresentada neste trabalho: a modelagem orientada a dados. A MOD é um termo 
relativamente novo, seu primeiro uso foi em 2009 por Noel Llopis~\cite{fabiandod}, mas 
a utilização de seus conceitos já foi apresentada em trabalho mais antigos. Sua 
principal filosofia é que programas devem focar em dados, e não em código. Isso 
significa não utilizar abstrações quando não são necessárias, utilizar um agrupamento 
inteligente dos dados, no qual dados relacionados estão próximos um dos outros na 
memória, enquanto dados não relacionados estão distantes. Além disso ocorre a separação 
de dados que são frequentemente requisitados pelo processador, daqueles que são menos 
utilizados, dessa maneira, esses dados pouco utilizados não irão poluir os caches da 
memória sem necessidade.

Apesar de parecer promissora, pouco se sabe sobre a MOD na área de desenvolvimento de 
jogos e motores de jogos. Isso se deve a pouco material disponível na literatura e 
também o fato de que a programação orientada a objetos está fortemente consolidada nessa 
área.

Um motor de jogos é uma maneira de se desenvolver jogos, e desde a sua introdução na 
indústria em 1993, têm revolucionado a produção de jogos com uma substancial redução 
de tempo, permitindo rápida prototipagem e desenvolvimento dos projetos, Também 
proporciona um alto grau de modularidade, permitindo a colaboração de equipes com mais de 
1000 membros no desenvolvimento dos projetos.

A implementação de um motor de jogos requer conhecimentos de diversas áreas diferentes, 
como Computação Gráfica, Álgebra Linear, Geometria Analítica, Inteligência Artificial, 
Processamento de Imagens, Física, entre outros. Isso faz com que esse tipo de programa 
seja consideravelmente interdisciplinar. Além disso o processo de desenvolvimento em si 
do sistema é complexo, não basta somente  implementação individual dos componentes que o 
constitui, mas também a concepção da arquitetura do motor, que irá determinar como esses 
componentes se comunicam entre si, processo necessário para a construção do loop de jogo.

O loop de jogo é o funcionamento principal da aplicação e sua estruturação é dependente da 
integração dos diferentes componentes do motor de jogos. É dividido em três partes 
maiores: detecção e gerenciamento de inputs, o processamento dos dados do jogo e a 
apresentação dos resultados. Esse loop deve ser adequadamente implementado para evitar 
que ele fique dependente da taxa de quadros por segundo, medida utilizada para o 
desempenho da aplicação. 

O uso da modelagem orientado a dados não garante uma melhora no 
desempenho, porém ao se seguir seus princípios, determinar o fluxo 
de dados da aplicação, agrupar dados relacionados na memória e 
implementar as funções de modo a descrever as transformações 
desejadas nos dados, têm-se um controle maior sobre o desempenho, 
pois se há o conhecimento de como os dados estão alocados e como 
são acessados na memória principal, isso facilita ao desenvolvedor 
implementar as funções de modo a otimizar a comunicação entre o 
processador e memória.

Determinar como os dados serão agrupados, alocados e acessados 
na memória é o maior desafio da modelagem orientada a dados. Para 
um desenvolvedor que já está familiarizado com a programação 
orientada a objetos, a conversão de uma abordagem para a outra pode 
não proporcionar os resultados desejados se as escolhas das 
estruturas não forem adequadas. O problema da MOD para a escolha das 
estruturas é que não há um padrão a se seguir, cada grupo de dados 
requer uma análise separada, isso ainda é dificultado pelo fato de 
que na MOD as estruturas não representam os objetos do mundo real 
de uma maneira tão direta quanto a programação orientada a objetos.

Os dois padrões de alocação de dados visto nesse trabalho, o AoS e 
o SoA, apresentaram vantagens e desvantagens nos resultados 
apresentados no capítulo~\ref{resultscap}, por isso pode-se concluir 
que nenhum destes é preferível à MOD, são necessários análises e 
testes para determinar qual padrão é mais adequado para cada caso. A 
tendência observada nos resultados foi que SoA tem seu desempenho 
inversamente proporcional ao número de propriedades utilizadas de 
uma entidade, tendo um desempenho ligeiramente mais lento do que 
o AoS para o método do motor que utiliza a maior quantidade de 
propriedades no problema A. 

Porém o modelo de leitura sequencial do 
SoA na versão OD do motor permitiu a implementação de um método de 
renderização mais robusto à mudanças na cena, o qual manteve um 
tempo de execução estável perante às mudanças na hierarquia dos 
objetos na cena no problema B, diferentemente da versão OO do motor, 
na qual houve um aumento cerca de 51\% no tempo de execução em 
relação ao problema A.
