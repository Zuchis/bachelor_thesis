\chapter{Considera\c{c}\~oes Finais}

A evolução do hardware de computadores chegou a um problema, onde se tem processadores 
extremamente rápidos porém uma velocidade de acesso à memória principal que foi incapaz de 
acompanhar essa evolução. As aplicações de computador que fazem acesso muito frequente à 
memória têm seu desempenho consideravelmente afetado por esse problema e precisa muitas 
vezes recorrer ao paralelismo, o que pode gerar vários problemas incluindo concorrência e 
imprevisibilidade dos dados, pois muitas vezes o paralelismo não estava planejado desde 
o início do projeto.

Jogos são uma categoria de aplicações gráficas que se encaixam nesse problema de acesso 
frequente a memória, isto porque há muitos dados externos que precisam ser carregado na 
aplicação, conhecidos como \textit{assets}, estes dados incluem: malhas, animações, sons, 
música, planos de fundo, fontes, texturas, entre outros. Por isso, são necessárias a 
leitura e armazenamento eficiente destes dados pois o bom desempenho em um jogo é 
essencial para garantir a experiência do jogador.

Existem outras soluções para esse problema além do paralelismo, uma delas foi 
apresentada neste trabalho: a modelagem orientada a dados. A MOD é um termo 
relativamente novo, seu primeiro uso foi em 2009 por Noel Llopis~\cite{fabiandod}, mas 
a utilização de seus conceitos já foi apresentada em trabalho mais antigos. Sua 
principal filosofia é que programas devem focar em dados, e não em código. Isso 
significa não utilizar abstrações quando não são necessárias, utilizar um agrupamento 
inteligente dos dados, no qual dados relacionados estão próximos um dos outros na 
memória, enquanto dados não relacionados estão distantes. Além disso ocorre a separação 
de dados que são frequentemente requisitados pelo processador, daqueles que são menos 
utilizados, dessa maneira, esses dados pouco utilizados não irão poluir os caches da 
memória sem necessidade.

Apesar de parecer promissora, pouco se sabe sobre a MOD na área de desenvolvimento de 
jogos e motores de jogos. Isso se deve a pouco material disponível na literatura e 
também o fato de que a programação orientada a objetos está fortemente consolidada nessa 
área.

Um motor de jogos é uma maneira de se desenvolver jogos, e desde a sua introdução na 
indústria em 1993, têm revolucionado a produção de jogos com uma substancial redução 
de tempo, permitindo rápida prototipagem e desenvolvimento, Também proporciona um 
alto grau de modularidade, permitindo a colaboração de equipes com mais de 1000 membros 
no desenvolvimento dos projetos.

A implementação de um motor de jogos requer conhecimentos de diversas áreas diferentes, 
como computação gráfica, álgebra linear, geometria analítica, inteligência artificial, 
processamento de imagens, física, entre outros. Isso faz com que esse tipo de programa 
seja consideravelmente interdisciplinar. Além disso o processo de desenvolvimento em si 
do sistema é complexo, não basta somente  implementação individual dos componentes que o 
constitui, mas também a concepção da arquitetura do motor, que irá determinar como esses 
componentes se comunicam entre si, processo necessário para a construção do loop de jogo.

O loop de jogo é o funcionamento principal da aplicação e sua estruturação é ditada pela 
integração dos diferentes componentes do motor de jogos. É dividido em três partes 
maiores: detecção e gerenciamento de inputs, o processamento dos dados do jogo e a 
apresentação dos resultados. Esse loop deve ser adequadamente implementado para evitar 
que ele fique dependente da taxa de quadros por segundo, medida utilizada para o 
desempenho da aplicação. Escolher a arquitetura certa para o loop de jogo não é uma 
tarefa trivial, principalmente porque as implementações dos motores de jogos varia 
consideravelmente, pois estas se adaptam com a complexidade dos projetos desenvolvidos 
nestas. Para este trabalho, a estruturação do loop de jogo é um trabalho em andamento.

Além de investigar o potencial da modelagem orientada a dados, este trabalho também pode 
ser considerado como um bom meio para testar o desempenho da linguagem Rust para a 
implementação de sistemas. O Rust tem o objetivo de ser uma linguagem eficiente e ter uso 
seguro da memória, problema frequente nas linguagens C e C++, a linguagem consegue 
atinjir esses objetivos através de abstrações sem custo, utilização de um sistema de 
posses e otimizações de compilação.

Para a análise e obtenção dos resultados, ainda há trabalho a ser feito. A seguir, 
serão discutidos alguns aspectos desta proposta que ainda não foram resolvidos.

\section{Escolha de Uma Arquitetura Adequada Para o Motor}

Segundo~\cite{Anderson2008}, um problema que ainda persiste é a falta de material na 
literatura que cobre a área de arquitetura de motor de jogoss. Além disso, não há material 
a respeito de motores de jogos com modelagem orientada a dados, o que torna essa tarefa 
ainda mais desafiadora. 

\section{Determinar a Aplicação a Ser Desenvolvida}

Conforme explicado na seção~\ref{proposalcap}, a implementação do motor de jogos não é o 
suficiente para testar o seu desempenho e realizar comparações, é necessário a 
implementação de uma aplicação que utilize as funcionalidades do motor de jogos. Por isso,
uma aplicação simples será desenvolvida em duas versões, uma com modelagem orientada a 
dados e a outra com programação orientada a objetos, como prova de conceito.

\section{Escolha Definitiva das Métricas para Medidas de Desempenho}

Apesar de se ter definido uma estratégia para realizar a análise e comparações do motor 
de jogos, ainda falta ser decidido as métricas de desempenho que serão empregadas 
nessas análises, pois, além do tempo de processamento, é necessário verificar o quão 
eficiente a memória será utilizada durante a execução da aplicação desenvolvida.

\section{Cronograma das Etapas Remanescentes}

Para as etapas remanescentes desta proposta, foi montado um cronograma com 
com as datas pretendidas para fazê-las. A seguir as etapas serão listadas:

\begin{enumerate}[label=\textnormal{(\arabic*)}]
    \item Finalizar o desenvolvimento do motor de jogos;
    \item Escrever as aplicações utilizadas para testes e comparações;
    \item Análise e comparação da performance da \textit{engine};
    \item Escrita da monografia da segunda parte, juntamente com o \textit{postmortem} da \textit{engine}.
\end{enumerate}

\vspace{0.5cm}

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[h!]
\centering
\caption{Cronograma da Segunda Parte}
\label{cronograma}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multicolumn{2}{|c|}{}                         & \multicolumn{6}{c|}{2017/02}                                                                                                                                                           \\ \cline{3-8} 
\multicolumn{2}{|c|}{\multirow{-2}{*}{Etapas}} & J                                               & A                        & S                                               & O                        & N                        & D \\ \hline
\multicolumn{2}{|l|}{1}                         & X & X &                                                 &                          &                          &   \\ \hline
\multicolumn{2}{|l|}{2}                         &                                                 & X & X &                          &                          &   \\ \hline
\multicolumn{2}{|l|}{3}                         &                                                 &                          &                                                 & X & X &   \\ \hline
\multicolumn{2}{|l|}{4}                         & X                        & X & X                & X & X &   \\ \hline
\end{tabular}
\end{table}
