\chapter{Introdução}
\label{intro}

Nas últimas décadas, os microprocessadores tiveram um enorme avanço em termos de performance. A função deste componente
essencial para os computadores modernos, que por vezes também é chamado de CPU (\textit{Central Process Unit}), é 
a de processar as instruções e os dados de todos os programas presentes no computador~\cite{Clements:2006:PCH:1214951}.

Além de executar essas instruções, o microprocessador está constantemente lendo e escrevendo dados na 
memória principal, a memória RAM (\textit{Random Access Memory})~\cite{Clements:2006:PCH:1214951}. Sem essa possibilidade 
de leitura e escrita, os programas de computador por si só não teriam muitas utilidades, e sistemas complexos não poderiam 
existir.

Porém, há um problema na comunicação entre o processador e a memória: ela não é instantânea. Um sistema no qual a memória 
pode fornecer qualquer dado para o processador instantaneamente não é factível. Por este motivo, sistemas de memória são 
projetados utilizando uma hierarquia, na qual a memória é dividida em diferentes camadas, cada uma com uma capacidade de 
armazenamento maior, porém com um tempo de acesso maior do processador~\cite{Mahapatra:1999:PBP:357783.331677}, a 
figura~\ref{memhier} demonstra essa hierarquia em ordem decrescente de velocidade. 

\begin{figure}[h!]
    \centering
    \captionof{figure}{A hierarquia do sistema de memória.}
    \includegraphics[width =.6\textwidth]{../figuras/memoryhierarchy}
    \par\medskip
    Fonte: Autoria própria.
    \label{memhier}
\end{figure}

As camadas do sistema de memória estão descritas a seguir: 

\begin{itemize}
    \item Registradores: são as porções da memória com o acesso mais rápido, porém em menor quantidade e com 
        pouca capacidade de armazenamento. São localizadas dentro do processador, e os compiladores são os responsáveis 
        por administrar os dados que ficam armazenados nos registradores~\cite{Clements:2006:PCH:1214951}.
    \item Cache: localizado próximo ao processador, fornece velocidade de acesso rápida e armazena código e dados utilizados 
        recentemente. Quando o processador tenta acessar algum dado presente no cache, ocorre um acerto do cache 
        (\textit{cache hit}), quando o dado não se encontra no cache, ocorre um erro do cache (\textit{cache miss}), e o dado 
        precisa ser buscado na memória principal~\cite{Mahapatra:1999:PBP:357783.331677}.
    \item Memória Principal, \textit{Dynamic Random Access Memory} (DRAM): em maior quantidade quando comparado ao cache,
        possui um custo menor, porém com um tempo de acesso 
        maior, é responsável por lidar com as operações de entrada e saída. Apesar de ser muito mais lenta do que o cache, sua 
        estrutura simplificada e relativamente baixo custo fez com que a DRAM se tornasse a memória principal dos sistemas 
        modernos~\cite{Mahapatra:1999:PBP:357783.331677}.
    \item Disco Rígido: possui a maior quantidade de armazenamento porém a custo de um tempo de leitura substancialmente maior, 
        quando um programa é executado os seus dados são carregados para a memória principal e a comunicação com o disco rígido 
        não é frequente, portanto essa unidade de memória não será objeto de estudo deste trabalho.
\end{itemize}

Como citado anteriormente, os processadores obtiveram um enorme avanço nos últimos tempos. Porém, a memória DRAM não foi 
capaz de acompanhar esse crescimento dos processadores na mesma velocidade. Desde a década de 1980 até a década de 1990, os 
processadores têm aprimorado a uma taxa de 60 porcento ao ano, enquanto que o tempo de acesso à DRAM tem aprimorado a uma 
taxa de menos de 10 porcento ao ano~\cite{Patterson:1997:CIR:623274.624083}. Mesmo com o rápido crescimento tecnológico, essas 
estatísticas de crescimento não sofreram alterações nas décadas de 2000 e 2010.

Essa disparidade de crescimento tem aumentado a lacuna de performance entre processador-memória, pois 
a latência de acesso a memória pelo processador está cada vez maior. Sempre que ocorre um \textit{cache miss}, o processador 
precisa ficar alguns ciclos ocioso enquanto aguarda o dado necessário ser buscado na memória 
principal~\cite{Mahapatra:1999:PBP:357783.331677}, como a velocidade de 
acesso à memória é relativamente muito menor do que a velocidade de processamento, um processador mais rápido significa apenas 
mais ciclos ociosos. Isso é conhecido como "Gargalo do Processador-Memória", e diante de tais limitações físicas, surge a 
necessidade de boas práticas de programação para que ocorra a menor quantidade de \textit{cache misses} o possível.

Com esse problema em mente, ao analisar o design de programação orientado objetos, percebe-se que essa abordagem, enquanto que 
mais legível e com código mais reutilizável, sofre muitas vezes em termos de eficiência de memória, pois seu design é centrado 
em torno do problema e suas possíveis soluções, e não em torno dos dados, fornecendo abstração dos dados porém a 
custo de desempenho.

Quando uma classe de objetos possui dados, chamados de atributos, isto significa que essa classe está fornecendo um contexto 
aos dados, e este pode comprometer o uso desses dados, pois ao adicionar métodos ao contexto, pode-se criar a necessidade 
de adicionar mais dados à classe, o que pode rapidamente levar à classes que contém diversos fragmentos de dados que não 
estão relacionados entre si~\cite{fabiandod}.

Outra desvantagem do uso demasiado de programação orientada a objetos, está em sua própria definição, que opera sobre um único 
objeto. Essa organização de dados não é benéfica ao processador, ao buscar objetos na memória para se realizar operações sobre 
atributos específicos destes, todos os outros dados pertencentes à classe também precisam ser carregados, deixando os caches 
poluídos com dados desnecessários e aumentando a incoerência de cache.

Com a premissa de amenizar o máximo possível estes problemas, a modelagem orientada a dados, como o nome sugere, encoraja a 
mudança da perspectiva da programação dos objetos para os dados, seus tipos, como está armazenado na memória e como será lido 
e processado~\cite{fabiandod}. Para alcançar esses objetivos, essa técnica sugere dividir cada objeto em diferentes 
componentes, e agrupar componentes do mesmo tipo na memória, sem se importar de qual objeto vieram. Isso resulta em largos 
blocos de dados homogêneos, permitindo o processamento sequencial dos dados, e garantindo um aprimoramento significativo 
no desempenho~\cite{fabiandod}.

Esta abordagem de modelagem é mais condizente com a realidade de muitos programas complexos, pois raramente há apenas um ou uma pequena 
quantidade de objetos de um determinado tipo, sendo necessário o processamento de todos eles. Mas esta abordagem não traz a 
solução para todos os problemas, e também possui suas desvantagens, uma delas é a falta de intuitividade para codificação 
orientada a dados. Uma das vantagens da orientação a objetos é a similaridade do pensamento com o mundo real e os seus 
problemas, deixando o código mais legível para os humanos. A modelagem orientada a dados requer que o programador raciocine com 
uma mentalidade muito diferente da qual a maioria está acostumada, e conceber código não intuitivo pode trazer complicações 
futuras para a adição de novas funcionalidades ou correções.

Para as aplicações na área de computação gráfica, esses problemas não seriam diferentes, principalmente levando em 
consideração que uma grande parte dos trabalhos nessa área utilizam a programação orientada a objetos. Essas aplicações, 
principalmente jogos eletrônicos modernos, utilizam um complexo sistema o qual possui muitos componentes diferentes que 
contém dados que constantemente transitam entre a memória, o processador e a GPU. Esse sistema é comumente conhecido 
como motor de jogo (do inglês \textit{Game Engine}), ou simplesmente como \textit{engine}.

Uma \textit{engine}, apesar de não possuir uma definição absoluta, é geralmente entendida como o software responsável por lidar com 
todos os módulos que juntos compõem um jogo eletrônico, como por exemplo, bibliotecas matemáticas (contendo operações de vetores, 
matrizes, quaternions, métodos trigonométricos, etc.), gerência de memória, 
estruturas de dados personalizadas, o motor de renderização, gerenciador de recursos, ferramentas para depuração e análise de performance, sistemas 
de colisão e física, sistema de animações e partículas, sistema de detecção de inputs (mouse, teclado e outros controladores),
sistema de áudio, sistema de rede para jogos online, entre outros~\cite{gregory2009game}.

Para complementar, uma \textit{engine}, ou motor de jogos, pode ser entendido como um conjunto de bibliotecas e ferramentas, os quais combinados 
são responsáveis por administrar toda a parte lógica de uma aplicação gráfica, separando-a em diferentes componentes utilizando as bibliotecas 
pra isso, por vezes também conhecidos como componentes núcleo, e também fornece utilidades que aceleram o processo de desenvolvimento 
das aplicações através das ferramentas. A introdução das \textit{engines} na indústria de jogos digitais também introduziu um novo paradigma, 
uma nova maneira de desenvolver os jogos, na qual é feita uma completa e clara separação do conteúdo lógico e do conteúdo criativo (arte, 
animações, música, sons, texturas, etc.).

O motor de renderização, também conhecido como motor gráfico, é um dos maiores e mais complexos componentes de um motor de 
jogos. E apesar de não possuir apenas uma única maneira de projetá-los, a maioria dos motores de renderização modernos 
seguem filosofias de design em comum~\cite{gregory2009game}. Esse componente será responsável por todos os métodos, 
estruturas e otimizações que serão responsáveis pela renderização dos gráficos e animações do jogo. 

Um dos elementos 
presentes no motor gráfico é uma interface de dispositivo gráficos, que será responsável pela comunicação com a GPU 
e, consequentemente, com a renderização de baixo nível. Uma das bibliotecas capazes de realizar essa função é o OpenGL, uma 
API gráfica para acessar os recursos da GPU, contendo um rico conjunto de comandos (mais de 500) que são utilizados para 
especificar objetos, imagens e operações necessárias para a renderização de aplicações gráficas~\cite{shreiner2013opengl}.

A programação em OpenGL moderno também requer o uso e entendimento de outro conceito igualmente importante, os shaders, que 
são pequenos programas que são especialmente compilados para a GPU e contém instruções que são executadas diretamente 
nesta~\cite{shreiner2013opengl}. Shaders em OpenGL utilizam uma linguagem de programação própria, o GLSL (\textit{OpenGL 
Shading Language})~\cite{shreiner2013opengl}.

Além dessa camada de renderização de baixo nível, o motor gráfico também conta com componentes essenciais de mais alto nível 
que são responsáveis pela gerência da geometria das malhas, como um grafo de cenas, que além de manipular as malhas estabelece 
a hierarquia entre elas e define subdivisões espaciais~\cite{gregory2009game}. Técnicas de otimizações também são importantes, 
como por exemplo a remoção parcial de objetos que não são considerados para contribuir à imagem final, essa técnica é 
conhecida como \textit{culling}~\cite{akenine2008real}.

Todos esses elementos, técnicas e otimizações do motor gráfico no fim constroem o que é conhecido como pipeline de 
renderização. A principal função desse pipeline é renderizar uma imagem bidimensional, 
dada uma câmera virtual, objetos tridimensionais, fontes de luz, equações de sombreamento, texturas, entre 
outros~\cite{akenine2008real}.

Considerando os problemas supracitados a respeito do gargalo de performance do processador-memória, e das desvantagens da 
programação orientada a objetos, este trabalho propõe a implementação de uma \textit{engine} desde o princípio com o objetivo de 
explorar o potencial da modelagem orientada a dados, um conceito pouco difundido entre a comunidade de programadores, 
e seus benefícios para aplicações gráficas, uma área na qual a orientação a objetos está fortemente impregnada. Uma vez
que uma \textit{engine} completa é uma aplicação consideravelmente grande e complexa, este trabalho irá se concentrar na implementação
do motor gráfico e suas otimizações. Para a implementação da \textit{engine}, foi escolhida a linguagem de programação Rust.

Rust é uma linguagem de programação de baixo nível, com tipagem estática e forte. A linguagem foi projetada com os objetivos 
de ser rápida, fácil de ser paralelizada e ter segurança de memória, prevenindo a ocorrência de condições de corrida, estouros 
de pilha, e acessos a posições de memória não inicializadas ou desalocadas~\cite{Matsakis:2014:RL:2692956.2663188}. Além disso, 
como a linguagem é relativamente nova e grande parte das aplicações gráficas são escritas em C ou C++, esse trabalho pode ser 
considerado um bom meio para testar o desempenho da linguagem.
