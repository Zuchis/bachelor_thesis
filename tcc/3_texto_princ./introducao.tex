\chapter{Introdução}
\label{intro}

Nas últimas décadas, os microprocessadores tiveram um enorme avanço em termos de desempenho. A função deste componente
essencial para os computadores modernos, que por vezes também é chamado de CPU (\textit{Central Process Unit}), é 
a de processar as instruções e os dados de todos os programas presentes no computador~\cite{Clements:2006:PCH:1214951}.

Além de executar essas instruções, o microprocessador está constantemente lendo e escrevendo dados na 
memória principal, a memória RAM (\textit{Random Access Memory})~\cite{Clements:2006:PCH:1214951}. Sem essa possibilidade 
de leitura e escrita, os programas de computador por si só não teriam muitas utilidades, e sistemas complexos não poderiam 
existir.

Porém, há um problema na comunicação entre o processador e a memória: ela não é instantânea. Um sistema no qual a memória 
pode fornecer qualquer dado para o processador instantaneamente não é factível. Por este motivo, sistemas de memória são 
projetados utilizando uma hierarquia, na qual a memória é dividida em diferentes camadas, cada uma com uma capacidade de 
armazenamento maior, porém com um tempo de acesso maior do processador~\cite{Mahapatra:1999:PBP:357783.331677}, a 
figura~\ref{memhier} demonstra essa hierarquia em ordem decrescente de velocidade. 

\begin{figure}[h!]
    \centering
    \captionof{figure}{A hierarquia do sistema de memória.}
    \includegraphics[width =.6\textwidth]{../figuras/memoryhierarchy}
    \par\medskip
    Fonte: Adaptado de~\cite{Toy1986}.
    \label{memhier}
\end{figure}

As camadas do sistema de memória estão descritas a seguir: 

\begin{itemize}
    \item Registradores: são as porções da memória com o acesso mais rápido, porém em 
        menor quantidade, com pouca capacidade de armazenamento e um alto custo de 
        fabricação, são localizados dentro do processador. Geralmente os programadores 
        não possuem controle sobre os registradores~\cite{Clements:2006:PCH:1214951}.
    \item Cache: localizado próximo ao processador, fornece velocidade de acesso rápida e armazena código e dados utilizados 
        recentemente. Quando o processador tenta acessar algum dado presente no cache, ocorre um acerto do cache 
        (\textit{cache hit}), quando o dado não se encontra no cache, ocorre um erro do cache (\textit{cache miss}), e o dado 
        precisa ser buscado na memória principal~\cite{Mahapatra:1999:PBP:357783.331677}.
    \item Memória Principal, \textit{Dynamic Random Access Memory} (DRAM): em maior quantidade quando comparado ao cache,
        possui um custo menor, porém com um tempo de acesso 
        maior, é responsável por lidar com as operações de entrada e saída. Apesar de ser muito mais lenta do que o cache, sua 
        estrutura simplificada e relativamente baixo custo fez com que a DRAM se tornasse a memória principal dos sistemas 
        modernos~\cite{Mahapatra:1999:PBP:357783.331677}.
    \item Disco Rígido: possui a maior quantidade de armazenamento porém a custo de um tempo de leitura substancialmente maior, 
        quando um programa é executado os seus dados são carregados para a memória principal e a comunicação com o disco rígido 
        não é frequente, portanto essa unidade de memória não será objeto de estudo deste trabalho.
\end{itemize}

Como citado anteriormente, os processadores obtiveram um enorme avanço nos últimos tempos. Porém, a memória DRAM não foi 
capaz de acompanhar esse crescimento dos processadores na mesma velocidade. Desde a década de 1980 até a década de 1990, os 
processadores têm aprimorado a uma taxa de 60 porcento ao ano, enquanto que o tempo de acesso à DRAM tem aprimorado a uma 
taxa de menos de 10 porcento ao ano~\cite{Patterson:1997:CIR:623274.624083}. Mesmo com o rápido crescimento tecnológico, essas 
estatísticas de crescimento não sofreram alterações nas décadas de 2000 e 2010.

Essa disparidade de crescimento tem aumentado a lacuna de desempenho entre processador-memória, pois 
a latência de acesso a memória pelo processador está cada vez maior. Sempre que ocorre um \textit{cache miss}, o processador 
precisa ficar alguns ciclos ocioso enquanto aguarda o dado necessário ser buscado na memória 
principal~\cite{Mahapatra:1999:PBP:357783.331677}, como a velocidade de 
acesso à memória é relativamente muito menor do que a velocidade de processamento, um processador mais rápido significa apenas 
mais ciclos ociosos. Isso é conhecido como "Gargalo do Processador-Memória", e diante de tais limitações físicas, surge a 
necessidade de boas práticas de programação para que ocorra a menor quantidade possível de \textit{cache misses}.

Com esse problema em mente, ao analisar o \textit{design} de programação orientada a 
objetos, percebe-se que essa abordagem, enquanto que mais legível e com código mais 
reutilizável, sofre muitas vezes em termos de eficiência de memória, pois seu 
\textit{design} é centrado em torno do problema e suas possíveis soluções, e não em torno 
dos dados. Ou seja, possui uma forte abstração dos dados porém a custo do desempenho.

Quando uma classe de objetos possui dados, chamados de atributos, isto significa que essa classe está fornecendo um contexto 
aos dados, e este pode comprometer o uso destes dados, pois ao adicionar métodos ao contexto, pode-se criar a necessidade 
de adicionar mais dados à classe, o que pode rapidamente levar à classes que contém diversos fragmentos de dados que não 
estão relacionados entre si~\cite{fabiandod}.

Outra desvantagem do uso demasiado de programação orientada a objetos, está em sua própria definição, que opera sobre um único 
objeto. Essa organização de dados não é benéfica ao processador, ao buscar objetos na memória para se realizar operações sobre 
atributos específicos destes, todos os outros dados pertencentes à classe também precisam ser carregados, deixando os caches 
poluídos com dados desnecessários e aumentando a incoerência de cache.

Com a premissa de amenizar o máximo possível estes problemas, a modelagem orientada a 
dados (MOD), como o nome sugere, encoraja a mudança da perspectiva da programação dos 
objetos para os dados, seus tipos, como estão armazenados na memória e como serão lidos e 
processados~\cite{fabiandod}. Para alcançar esses objetivos, essa técnica sugere dividir 
cada objeto em diferentes componentes, e agrupar componentes do mesmo tipo na memória, 
sem se importar de qual objeto vieram. Isso resulta em largos blocos de dados homogêneos, 
permitindo o processamento sequencial dos dados, e garantindo um aprimoramento 
significativo no desempenho~\cite{fabiandod}.

Esta abordagem de modelagem é mais condizente com a realidade de muitos programas complexos, pois raramente há apenas um ou uma pequena 
quantidade de objetos de um determinado tipo, sendo necessário o processamento de todos eles. Mas esta abordagem não traz a 
solução para todos os problemas, e também possui suas desvantagens, uma delas é a falta de intuitividade para codificação 
orientada a dados. Uma das vantagens da orientação a objetos é a similaridade do pensamento com o mundo real e os seus 
problemas, deixando o código mais legível para os humanos. A modelagem orientada a dados 
requer um raciocício menos natural comparado à modelagem orientada a objetos, tornando 
por vezes o código menos intuitivo.

Para as aplicações na área de computação gráfica, esses problemas não seriam diferentes, principalmente levando em 
consideração que uma grande parte dos trabalhos nessa área utilizam a programação orientada a objetos. Essas aplicações, 
principalmente jogos eletrônicos modernos, utilizam um complexo sistema o qual possui muitos componentes diferentes que 
contém dados que constantemente transitam entre a memória, o processador e a GPU. Esse sistema é comumente conhecido 
como motor de jogos (do inglês \textit{Game Engine}), ou simplesmente como \textit{engine}.

Um motor de jogos, apesar de não possuir uma definição absoluta, é geralmente entendida como o software responsável por lidar com 
todos os módulos que juntos compõem um jogo eletrônico, como por exemplo, bibliotecas matemáticas (contendo operações de vetores, 
matrizes, quaternions, métodos trigonométricos, etc.), gerência de memória, 
estruturas de dados personalizadas, o motor de renderização, gerenciador de recursos, ferramentas para depuração e análise de desempenho, sistemas 
de colisão e física, sistema de animações e partículas, sistema de detecção de inputs (mouse, teclado e outros controladores),
sistema de áudio, sistema de rede para jogos online, entre outros~\cite{gregory2009game}.

Para complementar, um motor de jogos pode ser entendido como um conjunto de bibliotecas e ferramentas, os quais combinados 
são responsáveis por administrar toda a parte lógica de uma aplicação gráfica. O motor é separado em diferentes componentes, 
que são conhecidos como componentes núcleo, estes fornecem utilidades que aceleram o processo de desenvolvimento 
das aplicações. A introdução dos motores de jogos na indústria de jogos digitais também introduziu um novo paradigma, 
uma nova maneira de desenvolver jogos, na qual é feita uma completa e clara separação do conteúdo lógico e do conteúdo criativo (arte, 
animações, música, sons, texturas, etc.).

O motor de renderização, também conhecido como motor gráfico, é um dos maiores e mais complexos componentes de um motor de 
jogos. E apesar de não possuir apenas uma única maneira de projetá-los, a maioria dos motores de renderização modernos 
seguem filosofias de \textit{design} em comum~\cite{gregory2009game}. Esse componente será responsável por todos os métodos, 
estruturas e otimizações que serão responsáveis pela renderização dos gráficos e animações do jogo. 

Um dos elementos 
presentes no motor gráfico é uma interface de dispositivo gráficos, que será responsável pela comunicação com a GPU 
e, consequentemente, com a renderização de baixo nível. Uma das bibliotecas capazes de realizar essa função é o OpenGL, uma 
API gráfica para acessar os recursos da GPU, contendo um rico conjunto de comandos (mais de 500) que são utilizados para 
especificar objetos, imagens e operações necessárias para a renderização de aplicações gráficas~\cite{shreiner2013opengl}.
Existem outras alternativas ao OpenGL que também são populares no mercado, como por 
exemplo o DirectX, desenvolvido pela Microsoft\textit{https://www.microsoft.com} e que ao 
longo dos anos foi também foi projetado para oferecer uma vasta gama de 
funcionalidades~\cite{zink2016practical}.

A programação em OpenGL moderno também requer o uso e entendimento de outro conceito 
igualmente importante, os \textit{shaders}, que são pequenos programas que são 
especialmente compilados para a GPU e suas instruções são executadas diretamente 
nos núcleos da GPU~\cite{shreiner2013opengl}. Shaders em OpenGL utilizam uma linguagem de 
programação própria, o GLSL (\textit{OpenGL Shading Language})~\cite{shreiner2013opengl}.

Além dessa camada de renderização de baixo nível, o motor gráfico também conta com componentes essenciais de mais alto nível 
que são responsáveis pela gerência da geometria das malhas, como um grafo de cenas, que além de manipular as malhas estabelece 
a hierarquia entre elas e define subdivisões espaciais~\cite{gregory2009game}. Técnicas de otimizações também são importantes, 
como por exemplo a remoção parcial de objetos que não são considerados para contribuir à imagem final, essa técnica é 
conhecida como \textit{culling}~\cite{akenine2008real}.

Todos esses elementos, técnicas e otimizações do motor gráfico no fim constroem o que é 
conhecido como \textit{pipeline} de renderização. A principal função desse 
\textit{pipeline} é renderizar uma imagem bidimensional, dada uma câmera virtual, objetos 
tridimensionais, fontes de luz, equações de sombreamento, texturas, entre 
outros~\cite{akenine2008real}.

Considerando os problemas supracitados a respeito do gargalo de desempenho do processador-memória, e das desvantagens da 
programação orientada a objetos, este trabalho propõe a implementação de um motor de jogos desde o princípio com o objetivo de 
explorar o potencial da modelagem orientada a dados, um conceito pouco difundido entre a comunidade de programadores, 
e seus benefícios para aplicações gráficas, uma área na qual a orientação a objetos está fortemente impregnada. Uma vez
que um motor de jogos completo é uma aplicação consideravelmente grande e complexa, este trabalho irá se concentrar na implementação
do motor gráfico e suas otimizações. Para a implementação do motor de jogos, foi escolhida a linguagem de programação Rust.

Rust é uma linguagem de programação de baixo nível, com tipagem estática e forte. A linguagem foi projetada com os objetivos 
de ser rápida, fácil de ser paralelizada e ter segurança de memória, prevenindo a ocorrência de condições de corrida, estouros 
de pilha, e acessos a posições de memória não inicializadas ou desalocadas~\cite{Matsakis:2014:RL:2692956.2663188}. Além disso, 
como a linguagem é relativamente nova e grande parte das aplicações gráficas são escritas em C ou C++, esse trabalho pode ser 
considerado um bom meio para testar o desempenho da linguagem.

\section{Objetivos}
\label{obj}

\textbf{Objetivo geral}: Investigar o potencial da modelagem orientada a dados para o 
desenvolvimento de um motor de jogos na linguagem de programação Rust e analisar sua 
eficiência e desempenho.\\

\noindent\textbf{Objetivos específicos}: 
Abaixo encontra-se uma lista dos principais objetivos a serem alcançados com este trabalho.
\begin{itemize}
    \item Verificar o estado atual no que diz respeito às implementações de motores de jogos modernos;
    \item Explorar o potencial e limitações da linguagem de programação Rust para aplicações gráficas;
    \item Utilizar o conceito de \textit{design} orientado a dados para proporcionar uma melhora
        no desempenho dos motores gráficos através da coerência de cache.
    \item Analisar o desempenho do motor de jogos, através do desenvolvimento de uma 
        aplicação que utilize suas funcionalidades em duas versões, uma orientada a 
        objetos e outra orientada a dados, comparando essas duas versões.
    \item Demonstrar as mudanças necessárias para converter uma aplicação orientada a 
        objetos para uma aplicação orientada a dados.
\end{itemize}

%------------------------------------------------
\section{Metodologia}
\label{met}

Após a etapa de revisão bibliográfica sobre 
os conceitos necessários para a implementação do motor de jogos e o estudo aprofundado da linguagem Rust e suas 
características avançadas, a aplicação será desenvolvida em etapas e o método utilizado será a implementação
dos componentes do motor sequencialmente, no qual estes serão testados individualmente.

A etapa seguinte será a integração dos componentes para a construção do \textit{pipeline} gráfico e implementação 
das outras funcionalidades. Com o motor de jogos tendo todos os seus componentes e características funcionando devidamente,
serão feitas análises e comparações de seu desempenho e eficiência, não somente do motor implementado, mas será 
também pesquisado na literatura outros motores de jogos já implementados e quais foram as medidas utilizadas para medir seus 
desempenhos. Por fim um \textit{postmortem} será escrito no TCC, explicando o que foi e o que não foi bem sucedido.

\section{Organização do Trabalho}
\label{paperstructure}

Este trabalho está organizado da seguinte forma, no Capítulo 2 estão contidos os 
fundamentos para o desenvolvimento do trabalho, o Capítulo 3 detalha alguns trabalhos 
relacionados com o tema deste projeto, já o Capítulo 4 apresenta o projeto dos sistemas 
a serem desenvolvidos e por fim, no Capítulo 5 estão contidas as considerações finais, 
seguidas pelas referências bibliográficas.
