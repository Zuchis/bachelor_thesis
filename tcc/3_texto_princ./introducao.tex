\chapter{Introdução}
\label{intro}

Nas últimas décadas, os microprocessadores tiveram um enorme avanço em termos de desempenho. A função deste componente
essencial para os computadores modernos, que por vezes também é chamado de CPU (\textit{Central Process Unit}), é 
a de processar as instruções e os dados de todos os programas presentes no computador~\cite{Clements:2006:PCH:1214951}.

Além de executar essas instruções, o microprocessador está constantemente lendo e escrevendo dados na 
memória principal, a memória RAM (\textit{Random Access Memory})~\cite{Clements:2006:PCH:1214951}. Se
os microprocessadores não fossem capazes de ler e escrever dados na memória, os programas de computador por si só não 
teriam muita utilidade, e sistemas complexos não poderiam existir.

Porém, há um problema na comunicação entre o processador e a memória: ela não é instantânea. Um sistema no qual a memória 
pode fornecer qualquer dado para o processador instantaneamente atualmente é inexistente. Por este motivo, sistemas de memória são 
projetados utilizando uma hierarquia, na qual a memória é dividida em diferentes camadas, cada uma com uma capacidade de 
armazenamento maior, porém com um tempo de acesso maior do processador~\cite{Mahapatra:1999:PBP:357783.331677}. A 
figura~\ref{memhier} demonstra essa hierarquia em ordem decrescente de velocidade. 

\begin{figure}[h!]
    \centering
    \captionof{figure}{A hierarquia do sistema de memória.}
    \includegraphics[width =.6\textwidth]{../figuras/memoryhierarchy}
    \par\medskip
    Fonte: Adaptado de~\cite{Toy1986}.
    \label{memhier}
\end{figure}

As camadas do sistema de memória estão descritas a seguir: 

\begin{itemize}
    \item Registradores: são as porções da memória com o acesso mais rápido, porém em 
        menor quantidade, com pouca capacidade de armazenamento e um alto custo de 
        fabricação, são localizados dentro do processador. Geralmente os programadores 
        não possuem controle sobre os registradores~\cite{Clements:2006:PCH:1214951}.
    \item Cache: localizado próximo ao processador, fornece velocidade de acesso rápida e armazena código e dados utilizados 
        recentemente. Quando o processador tenta acessar dados no cache, ocorre um acerto do cache 
        (\textit{cache hit}) caso os dados estejam presente. Quando os dados não se encontram no cache, ocorre um erro do cache 
        (\textit{cache miss}), e os dados precisam ser buscados na memória principal~\cite{Mahapatra:1999:PBP:357783.331677}.
    \item Memória Principal, \textit{Dynamic Random Access Memory} (DRAM): em maior quantidade quando comparado ao cache,
        possui um custo menor, porém com um tempo de acesso 
        maior, é responsável por lidar com as operações de entrada e saída. Apesar de ser muito mais lenta do que o cache, sua 
        estrutura simplificada e relativamente baixo custo fez com que a DRAM se tornasse a memória principal dos sistemas 
        modernos~\cite{Mahapatra:1999:PBP:357783.331677}.
    \item Disco Rígido: possui a maior quantidade de armazenamento porém a custo de um tempo de leitura substancialmente maior, 
        quando um programa é executado os seus dados são carregados para a memória principal e a comunicação com o disco rígido 
        não é frequente, portanto essa unidade de memória não será objeto de estudo deste trabalho.
\end{itemize}

Como citado anteriormente, os processadores obtiveram um enorme avanço nos últimos tempos. Porém, a memória DRAM não foi 
capaz de acompanhar esse crescimento dos processadores na mesma velocidade. Desde a década de 1980 até a década de 1990, os 
processadores têm aprimorado a uma taxa de 60 porcento ao ano, enquanto que o tempo de acesso à DRAM tem aprimorado a uma 
taxa de menos de 10 porcento ao ano~\cite{Patterson:1997:CIR:623274.624083}. Mesmo com o rápido crescimento tecnológico, essas 
estatísticas de crescimento não sofreram alterações nas décadas de 2000 e 2010.

Essa disparidade de crescimento tem aumentado a lacuna de desempenho entre processador-memória, pois 
a latência de acesso a memória pelo processador está cada vez maior. Sempre que ocorre um \textit{cache miss}, o processador 
precisa ficar alguns ciclos ocioso enquanto aguarda o dado necessário ser buscado na memória 
principal~\cite{Mahapatra:1999:PBP:357783.331677}. Como a velocidade de 
acesso à memória é relativamente muito menor do que a velocidade de processamento, um processador mais rápido significa apenas 
mais ciclos ociosos. Isso é conhecido como "Gargalo do Processador-Memória", e diante de tais limitações físicas, surge a 
necessidade de boas práticas de programação para que ocorra a menor quantidade possível de \textit{cache misses}.

Com esse problema em mente, ao analisar o \textit{design} de programação orientada a 
objetos, percebe-se que essa abordagem, enquanto que mais legível e com código mais 
reutilizável, sofre muitas vezes em termos de eficiência de memória, pois seu 
\textit{design} é centrado em torno do problema e suas possíveis soluções, e não em torno 
dos dados. Ou seja, possui uma forte abstração dos dados porém a custo do desempenho.

Quando uma classe de objetos possui dados, chamados de atributos, isto significa que essa classe está fornecendo um contexto 
aos dados, e este pode comprometer o uso destes dados, pois ao adicionar métodos ao contexto, pode-se criar a necessidade 
de adicionar mais dados à classe, o que pode rapidamente levar à classes que contém diversos fragmentos de dados que não 
estão relacionados entre si~\cite{fabiandod}.

Com a premissa de amenizar o máximo possível estes problemas, o projeto orientado a 
dados, (MOD), como o nome sugere, encoraja a mudança da perspectiva da programação dos 
objetos para os dados, seus tipos, como estão armazenados na memória e como serão lidos e 
processados~\cite{fabiandod}. Para alcançar esses objetivos, essa técnica sugere dividir 
cada objeto em diferentes componentes, e agrupar componentes do mesmo tipo na memória, 
sem se importar de qual objeto vieram. Isso resulta em grandes blocos de dados homogêneos, 
permitindo o processamento sequencial dos dados, e garantindo um aprimoramento 
significativo no desempenho~\cite{fabiandod}.

Esta abordagem de modelagem é mais condizente com a realidade de muitos programas complexos, pois raramente há apenas um ou uma pequena 
quantidade de objetos de um determinado tipo, sendo necessário o processamento de todos eles. Mas esta abordagem não traz a 
solução para todos os problemas, e também possui suas desvantagens, sendo uma delas a falta de intuitividade para codificação 
orientada a dados. Uma das vantagens da orientação a objetos é a similaridade do pensamento com o mundo real e os seus 
problemas, deixando o código mais legível para os humanos. A projeto orientado a dados 
requer um raciocício menos natural comparado à programação orientada a objetos, tornando 
por vezes o código menos intuitivo.

Para as aplicações na área de computação gráfica, esses problemas não seriam diferentes, principalmente levando em 
consideração que uma grande parte dos trabalhos nessa área utilizam a programação orientada a objetos. Essas aplicações, 
principalmente jogos eletrônicos modernos, utilizam um complexo sistema o qual possui muitos componentes diferentes que 
contém dados que constantemente transitam entre a memória, o processador e a GPU. Esse sistema é comumente conhecido 
como motor de jogos (do inglês \textit{Game Engine}), ou simplesmente como \textit{engine}.

Um motor de jogos, apesar de não possuir uma definição absoluta, é geralmente entendida como o software responsável por lidar com 
todos os módulos que juntos compõem um jogo eletrônico, como por exemplo, bibliotecas matemáticas (contendo operações de vetores, 
matrizes, quaternions, métodos trigonométricos, etc.), gerência de memória, 
estruturas de dados personalizadas, o motor de renderização, gerenciador de recursos, ferramentas para depuração e análise de desempenho, sistemas 
de colisão e física, sistema de animações e partículas, sistema de detecção de \textit{inputs} (mouse, teclado e outros controladores),
sistema de áudio, sistema de rede para jogos online, entre outros~\cite{gregory2009game}.

Para complementar, um motor de jogos pode ser entendido como um conjunto de bibliotecas e ferramentas, os quais combinados 
são responsáveis por administrar toda a parte lógica de uma aplicação gráfica. O motor é separado em diferentes componentes, 
que são conhecidos como componentes núcleo, estes fornecem utilidades que aceleram o processo de desenvolvimento 
das aplicações. A introdução dos motores de jogos na indústria de jogos digitais também introduziu um novo paradigma, 
uma nova maneira de desenvolver jogos, na qual é feita uma completa e clara separação do conteúdo lógico e do conteúdo criativo (arte, 
animações, música, sons, texturas, etc.).

O motor de renderização, também conhecido como motor gráfico, é um dos maiores e mais complexos componentes de um motor de 
jogos. E apesar de não possuir apenas uma única maneira de projetá-los, a maioria dos motores de renderização modernos 
seguem filosofias de \textit{design} em comum~\cite{gregory2009game}. Esse componente será responsável por todos os métodos, 
estruturas e otimizações que serão responsáveis pela renderização dos gráficos e animações do jogo. 

Um dos elementos 
presentes no motor gráfico é uma interface de dispositivo gráficos, que será responsável pela comunicação com a GPU 
e, consequentemente, com a renderização de baixo nível. Uma das bibliotecas capazes de realizar essa função é o OpenGL, uma 
API gráfica para acessar os recursos da GPU, contendo um rico conjunto de comandos (mais de 500) que são utilizados para 
especificar objetos, imagens e operações necessárias para a renderização de aplicações gráficas~\cite{shreiner2013opengl}.
Existem outras alternativas ao OpenGL que também são populares no mercado, como por 
exemplo o DirectX, desenvolvido pela Microsoft\footnote{\textit{https://www.microsoft.com}} e que ao 
longo dos anos foi também foi projetado para oferecer uma vasta gama de 
funcionalidades~\cite{zink2016practical}.

A programação em OpenGL moderno também requer o uso e entendimento de outro conceito 
igualmente importante, os \textit{shaders}, que são pequenos programas que são 
especialmente compilados para a GPU e suas instruções são executadas diretamente 
nos núcleos da GPU~\cite{shreiner2013opengl}. Shaders em OpenGL utilizam uma linguagem de 
programação própria, o GLSL (\textit{OpenGL Shading Language})~\cite{shreiner2013opengl}.

Além dessa camada de renderização de baixo nível, o motor gráfico também conta com componentes essenciais de mais alto nível 
que são responsáveis pela gerência da geometria das malhas, como um grafo de cenas, que além de manipular as malhas estabelece 
a hierarquia entre elas e define subdivisões espaciais~\cite{gregory2009game}. Técnicas de otimizações também são importantes, 
como por exemplo a remoção parcial de objetos que não são considerados para contribuir à imagem final, essa técnica é 
conhecida como \textit{culling}~\cite{akenine2008real}.

Todos esses elementos, técnicas e otimizações do motor gráfico no fim constroem o que é 
conhecido como \textit{pipeline} de renderização. A principal função desse 
\textit{pipeline} é renderizar uma imagem bidimensional, dada uma câmera virtual, objetos 
tridimensionais, fontes de luz, equações de sombreamento, texturas, entre 
outros~\cite{akenine2008real}.

Considerando os problemas supracitados a respeito do gargalo de desempenho do processador-memória, e das desvantagens da 
programação orientada a objetos, este trabalho propõe a implementação de um motor de jogos desde o princípio com o objetivo de 
explorar o potencial da projeto orientado a dados, um conceito pouco difundido entre a comunidade de programadores, 
e seus benefícios para aplicações gráficas, uma área na qual a orientação a objetos está fortemente impregnada. Uma vez
que um motor de jogos completo é uma aplicação consideravelmente grande e complexa, neste trabalho concentrou-se na implementação
do motor gráfico e suas otimizações.

\section{Objetivos}
\label{obj}

\textbf{Objetivo geral}: Investigar o potencial da projeto orientado a dados para o 
desenvolvimento de um motor de jogos e analisar sua eficiência e desempenho.\\

\noindent\textbf{Objetivos específicos}: 
Abaixo encontra-se uma lista dos principais objetivos a serem alcançados com este trabalho.
\begin{itemize}
    \item Verificar o estado atual no que diz respeito às implementações de motores de jogos modernos;
    \item Utilizar o conceito de \textit{design} orientado a dados para proporcionar uma melhora
        no desempenho dos motores gráficos através da coerência de cache.
    \item Analisar o desempenho do motor de jogos, através do desenvolvimento de uma 
        aplicação que utilize suas funcionalidades em duas versões, uma orientada a 
        objetos e outra orientada a dados, comparando essas duas versões.
    \item Demonstrar as mudanças necessárias para converter uma aplicação orientada a 
        objetos para uma aplicação orientada a dados.
\end{itemize}

%------------------------------------------------
\section{Metodologia}
\label{met}

Após a etapa de revisão bibliográfica sobre os conceitos necessários para 
a implementação do motor de jogos, este foi desenvolvido em duas versões 
diferentes. Primeiramente foi feita a implementação de um motor de jogos seguindo 
os conceitos tradicionais da programação orientada a objetos, este motor foi desenvolvido 
em etapas separadas,
onde em cada uma foi implementado um componente diferente. Depois de 
ter todos os componentes implementados e funcionando devidamente, foi 
desenvolvido o núcleo do motor, responsável por gerenciar as 
relações entre os componentes e formar o \textit{loop} de jogo, conforme será 
visto na seção~\ref{gameloopsec}.

A segunda versão foi desenvolvida utilizando os conceitos estudados do projeto 
orientado a dados a partir da primeira versão, realizando um processo de conversão 
entre uma abordagem e outra. Com as duas versões implementadas, foram feitas análises e 
comparações do desempenho e eficiência das duas versões.

\section{Organização do Trabalho}
\label{paperstructure}

Este trabalho está organizado da seguinte forma, no Capítulo 2 estão contidos os 
fundamentos para o desenvolvimento do trabalho, o Capítulo 3 detalha alguns trabalhos 
relacionados com o tema deste projeto, já o Capítulo 4 apresenta o projeto dos motores 
desenvolvidos e as diferenças entre os dois. No capítulo~\ref{resultscap} estão os resultados 
de desempenho e comparações entre as duas abordagens e por fim, no Capítulo 6 estão contidas 
as considerações finais, seguidas pelas referências bibliográficas.
